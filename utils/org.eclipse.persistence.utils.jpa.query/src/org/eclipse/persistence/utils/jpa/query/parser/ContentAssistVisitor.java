/*******************************************************************************
 * Copyright (c) 2006, 2011 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0
 * which accompanies this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Oracle - initial API and implementation
 *
 ******************************************************************************/
package org.eclipse.persistence.utils.jpa.query.parser;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import org.eclipse.persistence.utils.jpa.query.DefaultContentAssistItems;
import org.eclipse.persistence.utils.jpa.query.parser.AbstractValidator.CollectionExpressionVisitor;
import org.eclipse.persistence.utils.jpa.query.parser.OrderByItem.Ordering;
import org.eclipse.persistence.utils.jpa.query.spi.IJPAVersion;
import org.eclipse.persistence.utils.jpa.query.spi.IQuery;

import static org.eclipse.persistence.utils.jpa.query.parser.AbstractExpression.*;

/**
 * This visitor traverses the JPQL parsed tree and gather the possible choices at a given position.
 * <p>
 * Note: It does not retrieve the possible state fields and collection valued fields because this
 * validator does not access to the application.
 *
 * @version 11.2.0
 * @since 11.2.0
 * @author Pascal Filion
 */
@SuppressWarnings("nls")
public final class ContentAssistVisitor extends AbstractTraverseParentVisitor {

	/**
	 * This is used to change the position of the cursor in order to add possible choices
	 */
	private Stack<Integer> corrections;

	/**
	 *
	 */
	private ClauseHelper<DeleteClause> deleteClauseHelper;

	/**
	 *
	 */
	private ClauseHelper<AbstractFromClause> fromClauseHelper;

	/**
	 *
	 */
	private ClauseHelper<GroupByClause> groupByClauseHelper;

	/**
	 *
	 */
	private ClauseHelper<HavingClause> havingClauseHelper;

	/**
	 * The set of possible choices gathered based on the position in the query.
	 */
	private DefaultContentAssistItems items;

	/**
	 * Used to prevent and infinite recursion when one of the visit method is virtually asking a
	 * child expression to be visited.
	 */
	private Expression lockedExpression;

	/**
	 *
	 */
	private ClauseHelper<OrderByClause> orderByClauseHelper;

	/**
	 * Used to determine if the cursor is an expression contained in a collection, if not, then this
	 * value is set to -1.
	 */
	private int positionInCollection;

	/**
	 * The external representation of the query used to retrieve the possible choices at a certain
	 * position.
	 */
	private IQuery query;

	/**
	 * Contains the position of the cursor within the parsed {@link Expression}.
	 */
	private QueryPosition queryPosition;

	/**
	 * A virtual space is used to move the position by an amount of space in order to find some
	 * choices within an expression. This is usually used when the trailing whitespace is not owned
	 * by the child expression but by one of its parents.
	 */
	private int virtualSpace;

	/**
	 *
	 */
	private ClauseHelper<WhereClause> whereClauseHelper;

	/**
	 * The current word based on the query and the position of the cursor. The word is what is on the
	 * left side of the cursor.
	 */
	private String word;

	/**
	 * This is used to retrieve words from the actual query.
	 */
	private WordParser wordParser;

	/**
	 * A constant for the length of a whitespace, which is 1.
	 */
	private static final int SPACE_LENGTH = 1;

	/**
	 * Creates a new <code>ContentAssistVisitor</code>.
	 *
	 * @param query The external representation of the JPQL query
	 * @param items The object used to store the possible choices gathered based on the position in
	 * the query
	 * @param queryPosition Contains the position of the cursor within the parsed {@link Expression}
	 * @param actualQuery The actual query is the text version of the query that may contain extra
	 * whitespace and different formatting than the trim down version generated by the parsed tree
	 */
	public ContentAssistVisitor(IQuery query, DefaultContentAssistItems items, QueryPosition queryPosition) {
		super();
		initialize(query, items, queryPosition);
	}

	private void addAbstractSchemaNames() {
		for (Iterator<String> iter = query.getProvider().entityNames(); iter.hasNext(); ) {
			String abstractSchemaName = iter.next();
			if (isValidChoice(abstractSchemaName, word)) {
				items.addAbstractSchemaName(abstractSchemaName);
			}
		}
	}

	private void addAllPossibleAggregates(JPQLQueryBNF queryBNF) {
		for (Iterator<String> iter = identifiers(queryBNF); iter.hasNext(); ) {
			addPossibleAggregate(iter.next());
		}
	}

	private void addAllPossibleAggregates(String queryBNFId) {
		addAllPossibleAggregates(queryBNF(queryBNFId));
	}

	private void addAllPossibleClauses(JPQLQueryBNF queryBNF) {
		for (Iterator<String> iter = identifiers(queryBNF); iter.hasNext(); ) {
			addPossibleClause(iter.next());
		}
	}

	private void addAllPossibleClauses(String queryBNFId) {
		addAllPossibleClauses(queryBNF(queryBNFId));
	}

	private void addAllPossibleCompoundFunctions(JPQLQueryBNF queryBNF, int position) {
		for (Iterator<String> iter = identifiers(queryBNF); iter.hasNext(); ) {
			addPossibleCompoundFunction(iter.next(), position);
		}
	}

	private void addAllPossibleCompoundFunctions(String queryBNFId, int position) {
		addAllPossibleCompoundFunctions(queryBNF(queryBNFId), position);
	}

	private void addAllPossibleFunctions(JPQLQueryBNF queryBNF) {
		addAllPossibleFunctions(queryBNF, queryPosition.getPosition());
	}

	private void addAllPossibleFunctions(JPQLQueryBNF queryBNF, int position) {
		for (Iterator<String> iter = identifiers(queryBNF); iter.hasNext(); ) {
			addPossibleFunction(iter.next(), position);
		}
	}

	private void addAllPossibleFunctions(String queryBNFId) {
		addAllPossibleFunctions(queryBNF(queryBNFId), queryPosition.getPosition());
	}

	private void addAllPossibleFunctions(String queryBNFId, int position) {
		addAllPossibleFunctions(queryBNF(queryBNFId), position);
	}

	private void addAllPossibleIdentifiers(JPQLQueryBNF queryBNF) {
		for (Iterator<String> iter = identifiers(queryBNF); iter.hasNext(); ) {
			addPossibleChoice(iter.next());
		}
	}

	private void addAllPossibleIdentifiers(String queryBNFId) {
		addAllPossibleIdentifiers(queryBNF(queryBNFId));
	}

	private void addIdentificationVariables() {
		addIdentificationVariables(IdentificationVariableType.ALL);
	}

	private void addIdentificationVariables(IdentificationVariableType type) {
		addIdentificationVariables(type, null);
	}

	private void addIdentificationVariables(IdentificationVariableType type, Expression expression) {

		// TODO: HANDLE IdentificationVariableType.LEFT and expression
		if (type == IdentificationVariableType.LEFT_RANGE || type == IdentificationVariableType.LEFT) {
			type = IdentificationVariableType.ALL;
		}

		// First retrieve visit the expression and gather the identification variables
		IdentificationVariableFromDeclarationVisitor visitor = new IdentificationVariableFromDeclarationVisitor(type);
		queryPosition.getExpression().getRoot().accept(visitor);

		for (String identificationVariable : visitor.identificationVariables) {
			if (isValidChoice(identificationVariable, word)) {
				items.addIdentificationVariable(identificationVariable);
				String abstractSchemaName = visitor.rangeIdentificationVariables.get(identificationVariable);
				if (abstractSchemaName != null) {
					items.addRangeIdentificationVariable(identificationVariable, abstractSchemaName);
				}
			}
		}
	}

	private void addLeftRangeIdentificationVariables() {
		addIdentificationVariables(IdentificationVariableType.LEFT_RANGE);
	}

	private void addPossibleAggregate(String choice) {
		if (isAggregate(choice)) {
			addPossibleChoice(choice);
		}
	}

	private void addPossibleChoice(String choice) {
		addPossibleChoice(choice, word);
	}

	private void addPossibleChoice(String identifier, String word) {

		if (isValidChoice(identifier, word) &&
		    isValidVersion(identifier))
		{
			items.addIdentifier(identifier);
		}
	}

	private void addPossibleClause(String identifier) {
		if (isClause(identifier)) {
			addPossibleChoice(identifier);
		}
	}

	private void addPossibleCompoundFunction(String choice, int position) {

		if (isCompoundFunction(choice)) {
			if (choice.indexOf(SPACE) > -1) {
				for (int index = choice.length(); --index > 0; ) {
					String partialWord = choice.substring(0, index);

					if (wordParser.endsWith(position, partialWord)) {
						if (choice.startsWith(NOT) && wordParser.previousWord(position - 1).equalsIgnoreCase(IS)) {
							return;
						}
						else {
							items.addIdentifier(choice);
							return;
						}
					}
				}
			}

			addPossibleChoice(choice);
		}
	}

	private void addPossibleFunction(String choice, int position) {

		if (isFunction(choice)) {
			String currentWord = word;
			int endPosition = position - word.length();

			// Check to see if the previous words are "IS", "IS NOT" and "NOT",
			// they are special case since the only allowed identifiers are
			// those starting with them
			if (wordParser.endsWith(endPosition, "IS NOT")) {
				currentWord = new StringBuilder("IS NOT ").append(word).toString();
			}
			else if (wordParser.endsWith(endPosition, "IS")) {
				currentWord = new StringBuilder("IS ").append(word).toString();
			}
			else if (wordParser.endsWith(endPosition, "NOT")) {
				currentWord = new StringBuilder("NOT ").append(word).toString();
			}
			else {
				addPossibleChoice(choice);
				currentWord = null;
			}

			if (currentWord != null                &&
			    isValidChoice(choice, currentWord) &&
			    isValidVersion(choice)) {

				items.addIdentifier(choice);
			}
		}
	}

	private void addPossibleIdentifier(String identifier, int position) {

		String currentWord = word;

		// Check for multiple words identifier
		if (identifier.indexOf(SPACE) > 0) {
			String previousWord = wordParser.previousWord(position);

			if (previousWord.length() > 0) {
				currentWord = new StringBuilder(previousWord).append(" ").append(word).toString();
			}
		}

		if (isValidChoice(identifier, currentWord) &&
		    isValidVersion(identifier)) {

			items.addIdentifier(identifier);
		}
		else {
			addPossibleChoice(identifier);
		}
	}

	private void addRangeIdentificationVariables() {
		addIdentificationVariables(IdentificationVariableType.RANGE);
	}

	private void addScalarExpressionChoices() {
		addIdentificationVariables();
		addAbstractSchemaNames();
		addAllPossibleFunctions(ScalarExpressionBNF.ID);
	}

	private SelectClauseCompletenessVisitor selectClauseCompletenessVisitor;

	private SelectClauseCompletenessVisitor selectClauseCompletenessVisitor() {
		if (selectClauseCompletenessVisitor == null) {
			selectClauseCompletenessVisitor = new SelectClauseCompletenessVisitor();
		}
		return selectClauseCompletenessVisitor;
	}

	private void addSelectExpressionChoices(Expression expression, int index, boolean last) {

		int position = position(expression);

		if (position == 0) {
			if (index == 0) {
				addPossibleChoice(DISTINCT);
			}
			addIdentificationVariables();
			addAllPossibleFunctions(SelectItemBNF.ID);
		}
		else {
			int length = length(expression);

			if (position == length) {
				// TODO Check for space
				if (isSelectExpressionComplete(expression)) {
					items.addIdentifier(AS);
					addAllPossibleAggregates(SelectItemBNF.ID);
				}
			}
		}

		if (last) {
			addPossibleChoice(FROM);
		}
	}

	private boolean isSelectExpressionComplete(Expression expression) {
		SelectClauseCompletenessVisitor visitor = selectClauseCompletenessVisitor();
		try {
			expression.accept(visitor);
			return visitor.complete;
		}
		finally {
			visitor.complete = false;
		}
	}

	private void addSelectExpressionChoices(AbstractSelectClause expression, int length) {

		int position = position(expression);

		// Now check for inside the select expression
		CollectionExpressionVisitor visitor = new CollectionExpressionVisitor();
		expression.getSelectExpression().accept(visitor);

		if (visitor.expression != null) {

			for (int index = 0, count = visitor.expression.childrenSize(); index < count; index++) {
				Expression child = visitor.expression.getChild(index);

				if (position == length) {
					addIdentificationVariables();
					addAllPossibleFunctions(SelectItemBNF.ID);
				}
				else {
					int childLength = length(child);

					if ((position == length + childLength) && isSelectExpressionComplete(child)) {
						items.addIdentifier(AS);
						addAllPossibleAggregates(SelectItemBNF.ID);
					}
				}

				length += length(child);

				if (visitor.expression.hasComma(index)) {
					length++;
				}

				if (visitor.expression.hasSpace(index)) {
					length++;
				}
			}
		}
		else {
			addSelectExpressionChoices(expression.getSelectExpression(), 0, true);
		}
	}

	private ClauseHelper<DeleteClause> buildDeleteClauseHelper() {
		return new DeleteClauseHelper();
	}

	private ClauseHelper<AbstractFromClause> buildFromClauseHelper() {
		return new FromClauseHelper();
	}

	private ClauseHelper<GroupByClause> buildGroupByClauseHelper() {
		return new GroupByClauseHelper();
	}

	private ClauseHelper<HavingClause> buildHavingClauseHelper() {
		return new HavingClauseHelper();
	}

	private ClauseHelper<OrderByClause> buildOrderByClauseHelper() {
		return new OrderByClauseHelper();
	}

	private ClauseHelper<WhereClause>buildWhereClauseHelper() {
		return new WhereClauseHelper();
	}

	private ClauseHelper<DeleteClause> deleteClauseHelper() {
		if (deleteClauseHelper == null) {
			deleteClauseHelper = buildDeleteClauseHelper();
		}
		return deleteClauseHelper;
	}

	private int findExpressionPosition(CollectionExpression expression) {

		Expression leafExpression = queryPosition.getExpression();

		if (leafExpression != expression) {
			for (int index = 0, count = expression.childrenSize(); index < count; index++) {
				Expression child = expression.getChild(index);

				if (child.isAncestor(leafExpression)) {
					return index;
				}
			}
		}

		int position = position(expression);

		if (position > -1) {
			for (int index = 0, count = expression.childrenSize(); index < count; index++) {
				Expression child = expression.getChild(index);
				String text = child.toParsedText();

				if (position <= text.length()) {
					return index;
				}

				position -= text.length();

				if (expression.hasComma(index)) {
					position--;
				}

				if (expression.hasSpace(index)) {
					position--;
				}
			}
		}

		if (position == 0 && (expression.endsWithComma() || expression.endsWithSpace())) {
			return expression.childrenSize();
		}

		return -1;
	}

	private ClauseHelper<AbstractFromClause> fromClauseHelper() {
		if (fromClauseHelper == null) {
			fromClauseHelper = buildFromClauseHelper();
		}
		return fromClauseHelper;
	}

	private ClauseHelper<GroupByClause> groupByClauseHelper() {
		if (groupByClauseHelper == null) {
			groupByClauseHelper = buildGroupByClauseHelper();
		}
		return groupByClauseHelper;
	}

	private ClauseHelper<HavingClause> havingClauseHelper() {
		if (havingClauseHelper == null) {
			havingClauseHelper = buildHavingClauseHelper();
		}
		return havingClauseHelper;
	}

	private IdentifierRole identifierRole(String identifier) {
		return AbstractExpression.identifierRole(identifier);
	}

	private Iterator<String> identifiers(JPQLQueryBNF queryBNF) {
		return queryBNF.identifiers();
	}

	private void initialize(IQuery query,
	                        DefaultContentAssistItems items,
	                        QueryPosition queryPosition) {

		this.positionInCollection        = -1;
		this.items                       = items;
		this.query                       = query;
		this.queryPosition               = queryPosition;
		this.wordParser                  = new WordParser(queryPosition.getExpression().getRoot().toParsedText());
		this.word                        = wordParser.partialWord(queryPosition.getPosition());

		this.corrections = new Stack<Integer>();
		this.corrections.add(0);
	}

	private boolean isAggregate(String choice) {
		return identifierRole(choice) == IdentifierRole.AGGREGATE;
	}

	private boolean isClause(String identifier) {
		return JPQLExpression.identifierRole(identifier) == IdentifierRole.CLAUSE;
	}

	private boolean isCompoundFunction(String choice) {
		return identifierRole(choice) == IdentifierRole.COMPOUND_FUNCTION;
	}

	private boolean isFunction(String choice) {
		return identifierRole(choice) == IdentifierRole.FUNCTION;
	}

	private boolean isLocked(Expression expression) {
		return lockedExpression == expression;
	}

	/**
	 * Determines whether the given position is within the given word.
	 * <p>
	 * Example: position=0, word="JPQL" => true
	 * Example: position=1, word="JPQL" => true
	 * Example: position=4, word="JPQL" => true
	 * Example: position=5, word="JPQL" => true
	 * Example: position=5, offset 2, (actual cursor position is 3), word="JPQL" => true
	 *
	 * @param position The position of the cursor
	 * @param offset The offset to adjust the position
	 * @param word The word to check if the cursor is positioned in it
	 * @return <code>true</code> if the given position is within the given word; <code>false</code>
	 * otherwise
	 */
	private boolean isPositionWithin(int position, int offset, String word) {
		return (position >= offset) && (position - offset <= word.length());
	}

	/**
	 * Determines whether the given position is within the given word.
	 * <p>
	 * Example: position=0, word="JPQL" => true
	 * Example: position=1, word="JPQL" => true
	 * Example: position=4, word="JPQL" => true
	 * Example: position=5, word="JPQL" => true
	 *
	 * @param position The position of the cursor
	 * @param word The word to check if the cursor is positioned in it
	 * @return <code>true</code> if the given position is within the given word; <code>false</code>
	 * otherwise
	 */
	private boolean isPositionWithin(int position, String word) {
		return isPositionWithin(position, 0, word);
	}

	private boolean isPositionWithin(String text, String matchingText, int position) {
		int index = text.toLowerCase().indexOf(matchingText.toLowerCase());
		return (position >= index) && (position <= index + matchingText.length());
	}

	private boolean isValidChoice(String choice, String word) {

		// There is no word to match the first letters
		if (word.length() == 0) {
			return true;
		}

		char character = word.charAt(0);

		if (character == '+' ||
		    character == '-' ||
		    character == '*' ||
		    character == '/') {

			return true;
		}

		// The word is longer than the choice
		if (word.length() > choice.length()) {
			return false;
		}

		// Check to see if the choice starts with the word
		for (int index = 0, length = word.length(); index < length; index++) {
			char character1 = choice.charAt(index);
			char character2 = word  .charAt(index);

			// If characters don't match but case may be ignored, try converting
			// both characters to uppercase. If the results match, then the
			// comparison scan should continue
			char upperCase1 = Character.toUpperCase(character1);
			char upperCase2 = Character.toUpperCase(character2);

			if (upperCase1 != upperCase2) {
				return false;
			}

			// Unfortunately, conversion to uppercase does not work properly for
			// the Georgian alphabet, which has strange rules about case
			// conversion. So we need to make one last check before exiting
			if (Character.toLowerCase(upperCase1) != Character.toLowerCase(upperCase2)) {
				return false;
			}
		}

		return true;
	}

	private boolean isValidVersion(String identifier) {
		IJPAVersion identifierVersion = JPQLExpression.identifierVersion(identifier);
		return version().isNewerThanOrEqual(identifierVersion);
	}

	private Expression lastLeaf(Expression expression) {

		for (Iterator<Expression> iter = expression.children(); iter.hasNext(); ) {
			Expression child = iter.next();

			if (!iter.hasNext()) {
				return lastLeaf(child);
			}
		}

		if (((AbstractExpression) expression).isNull()) {
			expression = expression.getParent();
		}

		return expression;
	}

	private int length(Expression expression) {
		return expression.toParsedText().length();
	}

	private ClauseHelper<OrderByClause> orderByClauseHelper() {
		if (orderByClauseHelper == null) {
			orderByClauseHelper = buildOrderByClauseHelper();
		}
		return orderByClauseHelper;
	}

	private int position(Expression expression) {
		return queryPosition.getPosition(expression);
	}

	private int position(Expression expression, char character) {
		return expression.toParsedText().indexOf(character);
	}

	private JPQLQueryBNF queryBNF(String queryBNFId) {
		return AbstractExpression.queryBNF(queryBNFId);
	}

	private IJPAVersion version() {
		return query.getProvider().getVersion();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(AbsExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(AbstractSchemaName expression) {
		// NOTE: MANUALLY TESTED
		// Adjust the position to be the "beginning" of the expression by adding a "correction"
		corrections.add(position(expression));
		super.visit(expression);
		corrections.pop();

		// Add the possible abstract schema names
		addAbstractSchemaNames();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(AdditionExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitArithmeticExpression(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(AllOrAnyExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, false, ALL, ANY, SOME);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(AndExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitLogicalExpression(expression, AND);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ArithmeticFactor expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();

		// After the arithmetic factor
		if (position == 1) {
			addIdentificationVariables();
			addAllPossibleFunctions(expression.getQueryBNF());
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(AvgFunction expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAggregateFunction(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(BadExpression expression) {
		// NOTE: MANUALLY TESTED
		corrections.add(position(expression));
		super.visit(expression);
		corrections.pop();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(BetweenExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);

		int position = position(expression) - corrections.peek();
		int length = 0;

		if (expression.hasExpression()) {
			length += length(expression.getExpression()) + SPACE_LENGTH;
		}

		// Within "NOT BETWEEN"
		if (expression.hasNot() && isPositionWithin(position, length, NOT_BETWEEN)) {
			items.addIdentifier(NOT_BETWEEN);
		}
		// Within "BETWEEN"
		else if (!expression.hasNot() && isPositionWithin(position, length, BETWEEN)) {
			items.addIdentifier(BETWEEN);
		}
		// After "BETWEEN "
		else if (expression.hasSpaceAfterBetween()) {
			length += expression.getIdentifier().length() + SPACE_LENGTH;

			// TODO: Check for the BETWEEN's expression type
			// Right after "BETWEEN "
			if (position == length) {
				addIdentificationVariables();
				addAllPossibleFunctions(InternalBetweenExpressionBNF.ID);
			}

			if (expression.hasLowerBoundExpression()) {
				length += length(expression.getLowerBoundExpression());

				if (expression.hasSpaceAfterLowerBound()) {
					length++;

					// At the end of the lower bound expression, AND is the only viable choice
					if (isPositionWithin(position, length, AND)) {
						addPossibleChoice(AND);
					}

					if (expression.hasAnd() &&
					    expression.hasSpaceAfterAnd()) {

						length += AND.length() + SPACE_LENGTH;

						// TODO: Check for the BETWEEN's expression type
						if (position == length) {
							addIdentificationVariables();
							addAllPossibleFunctions(InternalBetweenExpressionBNF.ID);
						}
					}
				}
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CaseExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();

		// Within "CASE"
		if (isPositionWithin(position, CASE)) {
			if (isValidVersion(CASE)) {
				items.addIdentifier(CASE);
			}
		}
		// After "CASE "
		else if (expression.hasSpaceAfterCase()) {
			int length = CASE.length() + SPACE_LENGTH;

			// Right after "CASE "
			if (position == length) {
				addIdentificationVariables();
				addAllPossibleFunctions(CaseOperandBNF.ID);
				items.addIdentifier(WHEN);
			}

			// After "<case operand> "
			if (expression.hasCaseOperand() &&
			    expression.hasSpaceAfterCaseOperand()) {

				length += length(expression.getCaseOperand()) + SPACE_LENGTH;

				// Right after "<case operand> "
				if (position == length) {
					items.addIdentifier(WHEN);
				}
			}

			// After "<when clauses> "
			if (expression.hasWhenClauses() &&
			    expression.hasSpaceAfterWhenClauses()) {

				length += length(expression.getWhenClauses()) + SPACE_LENGTH;

				// Right after "<when clauses> "
				if (isPositionWithin(position, length, ELSE)) {
					items.addIdentifier(ELSE);
				}

				// After "ELSE "
				if (expression.hasElse() &&
				    expression.hasSpaceAfterElse()) {

					length += ELSE.length() + SPACE_LENGTH;

					// Right after "ELSE "
					if (position == length) {
						addIdentificationVariables();
						addAllPossibleFunctions(CaseOperandBNF.ID);
					}

					// After "<else expression> "
					if (expression.hasElseExpression() &&
					    expression.hasSpaceAfterElseExpression()) {

						length += length(expression.getElseExpression()) + SPACE_LENGTH;

						// Right after "<else expression> "
						if (isPositionWithin(position, length, END)) {
							items.addIdentifier(END);
						}
					}
				}
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CoalesceExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CollectionExpression expression) {
		// NOTE: MANUALLY TESTED
		// Adjust the index within the collection
		positionInCollection = findExpressionPosition(expression);
		if (positionInCollection > -1) {
			corrections.add(position(expression));
		}

		super.visit(expression);

		// Dispose of the data
		if (positionInCollection > -1) {
			corrections.pop();
		}
		positionInCollection = -1;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CollectionMemberDeclaration expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();

		// Within "IN"
		if (isPositionWithin(position, IN)) {
			items.addIdentifier(IN);
		}

		// In a subquery only
		SubqueryVisitor visitor = new SubqueryVisitor();
		expression.accept(visitor);

		// After "IN "
		if ((visitor.expression != null) && expression.hasSpaceAfterIn()) {
			int length = IN.length() + SPACE_LENGTH;

			// Right after "IN "
			if (position == length) {
				// TODO: Type.SuperQueryIdentificationVariable
				addRangeIdentificationVariables();
			}
		}
		// In a top-level query or subquery
		// After "IN("
		else if (expression.hasLeftParenthesis()) {
			int length = IN.length() + 1 /* '(' */;

			// Right after "IN("
			if (position == length) {
				addLeftRangeIdentificationVariables();
			}

			// After "<collection-valued path expression>)"
			if (expression.hasRightParenthesis()) {
				length += length(expression.getCollectionValuedPathExpression()) + 1 /* ')' */;

				// Right after "<collection-valued path expression>)"
				if ((position == length) && !expression.hasSpaceAfterRightParenthesis()) {
					items.addIdentifier(AS);
				}

				if (expression.hasSpaceAfterRightParenthesis()) {
					length++;
				}

				// Within "AS"
				if (isPositionWithin(position, length, AS)) {
					items.addIdentifier(AS);
				}
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CollectionMemberExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();
		String identifier = expression.getIdentifier();
		int length = 0;

		if (expression.hasEntityExpression()) {
			length = length(expression.getEntityExpression()) + SPACE_LENGTH;
		}

		// Within the <identifier>
		if (isPositionWithin(position, length, identifier)) {
			items.addIdentifier(NOT_MEMBER);
			items.addIdentifier(NOT_MEMBER_OF);
			items.addIdentifier(MEMBER);
			items.addIdentifier(MEMBER_OF);
		}
		// After the <identifier>
		else if (expression.hasOf() && expression.hasSpaceAfterOf() ||
		        !expression.hasOf() && expression.hasSpaceAfterMember()) {

			length += identifier.length() + SPACE_LENGTH;

			// Right after the <identifier>
			if (position == length) {
				addIdentificationVariables();
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CollectionValuedPathExpression expression) {
		// NOTE: MANUALLY TESTED
		if (!expression.hasIdentificationVariable()) {
			corrections.add(position(expression));
			super.visit(expression);
			corrections.pop();
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ComparisonExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();
		int length = 0;

		if (expression.hasLeftExpression()) {
			length += length(expression.getLeftExpression()) + SPACE_LENGTH;
		}

		// Within the comparison operator
		if (isPositionWithin(position, length, expression.getComparisonOperator())) {
			items.addIdentifier(LOWER_THAN);
			items.addIdentifier(LOWER_THAN_OR_EQUAL);
			items.addIdentifier(DIFFERENT);
			items.addIdentifier(EQUAL);
			items.addIdentifier(GREATER_THAN);
			items.addIdentifier(GREATER_THAN_OR_EQUAL);
		}
		// After the comparison operator
		else {
			length += expression.getComparisonOperator().length();

			if (expression.hasSpaceAfterIdentifier()) {
				length++;
			}

			// Right after the comparison operator
			if (position == length) {
				addAllPossibleFunctions(expression.rightExpressionBNF());
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ConcatExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ConstructorExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();

		// NEW
		if (isPositionWithin(position, NEW)) {
			items.addIdentifier(NEW);
		}
		// After "NEW "
		else if (expression.hasSpaceAfterNew()) {
			int length = NEW.length() + SPACE_LENGTH;

			// Right after "NEW "
			if (position == length) {
				// TODO: Show all the instantiable classes
			}

			// After "("
			if (expression.hasLeftParenthesis()) {
				String className = expression.getClassName();
				length += className.length() + SPACE_LENGTH;

				// Right after "("
				if (position == length) {
					addIdentificationVariables();
					addAllPossibleFunctions(ConstructorItemBNF.ID);
				}
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CountFunction expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAggregateFunction(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(DateTime expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();;

		// Within the identifier
		if (isPositionWithin(position, CURRENT_DATE) ||
		    isPositionWithin(position, CURRENT_TIME) ||
		    isPositionWithin(position, CURRENT_TIMESTAMP)) {

			items.addIdentifier(CURRENT_DATE);
			items.addIdentifier(CURRENT_TIME);
			items.addIdentifier(CURRENT_TIMESTAMP);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(DeleteClause expression) {
		// NOTE: MANUALLY TESTED
		if (!isLocked(expression)) {
			super.visit(expression);
			visitClause(expression, DELETE_FROM, expression.hasSpaceAfterFrom(), deleteClauseHelper());
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(DeleteStatement expression) {
		super.visit(expression);

		int position            = position(expression);
		int deleteClauseLength  = length(expression.getDeleteClause());

		// The cursor is right after "DELETE FROM ... "
		if (position - corrections.peek() == deleteClauseLength + SPACE_LENGTH) {
			addPossibleChoice(WHERE);
		}
		// The position is after the DeleteStatement, which means it's in the
		// JPQLExpression's unknown statement
		else if (virtualSpace != 0 && position == deleteClauseLength + SPACE_LENGTH) {
			addPossibleChoice(WHERE);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(DivisionExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitArithmeticExpression(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(EmptyCollectionComparisonExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();
		int length = 0;

		if (expression.hasExpression()) {
			length = length(expression.getExpression()) + SPACE_LENGTH;
		}

		// Within the <identifier>
		if (isPositionWithin(position, length, expression.getIdentifier())) {
			items.addIdentifier(IS_EMPTY);
			items.addIdentifier(IS_NOT_EMPTY);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(EntityTypeLiteral expression) {
		// NOTE: MANUALLY TESTED
		// Adjust the position to be the "beginning" of the expression by adding a "correction"
		corrections.add(position(expression));
		super.visit(expression);
		corrections.pop();

		// Add the possible abstract schema names
		addAbstractSchemaNames();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(EntryExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ExistsExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, false, EXISTS, NOT_EXISTS);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(FromClause expression) {
		// NOTE: MANUALLY TESTED
		if (!isLocked(expression)) {
			super.visit(expression);
			visitClause(expression, FROM, expression.hasSpaceAfterFrom(), fromClauseHelper());
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(FuncExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, false);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(GroupByClause expression) {
		// NOTE: MANUALLY TESTED
		if (!isLocked(expression)) {
			super.visit(expression);
			visitClause(expression, GROUP_BY, expression.hasSpaceAfterGroupBy(), groupByClauseHelper());
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(HavingClause expression) {
		// NOTE: MANUALLY TESTED
		if (!isLocked(expression)) {
			super.visit(expression);
			visitClause(expression, HAVING, expression.hasSpaceAfterIdentifier(), havingClauseHelper());
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(IdentificationVariable expression) {
		// NOTE: MANUALLY TESTED
		// Adjust the position to be the "beginning" of the expression by adding a "correction"
		corrections.add(position(expression));
		super.visit(expression);
		corrections.pop();

		// Add the possible identification variables
		addIdentificationVariables();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(IdentificationVariableDeclaration expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);

		// After the range variable declaration
		if (expression.hasSpace()) {
			int position = position(expression) - corrections.peek();
			int length = length(expression.getRangeVariableDeclaration()) + SPACE_LENGTH;

			// Right after the range variable declaration
			if (position == length) {
				addPossibleChoice(INNER_JOIN);
				addPossibleChoice(INNER_JOIN_FETCH);
				addPossibleChoice(JOIN);
				addPossibleChoice(JOIN_FETCH);
				addPossibleChoice(LEFT_JOIN);
				addPossibleChoice(LEFT_JOIN_FETCH);
				addPossibleChoice(LEFT_OUTER_JOIN);
				addPossibleChoice(LEFT_OUTER_JOIN_FETCH);
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(IndexExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(InExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();
		int length = 0;

		if (expression.hasExpression()) {
			length += length(expression.getExpression()) + SPACE_LENGTH;
		}

		// Within "IN"
		if (isPositionWithin(position, length, expression.getIdentifier())) {
			items.addIdentifier(IN);
			items.addIdentifier(NOT_IN);
		}
		// After "IN("
		else if (expression.hasLeftParenthesis()) {
			length += expression.getIdentifier().length() + SPACE_LENGTH;

			// Right after "IN("
			if (position == length) {
				addAllPossibleFunctions(InItemBNF.ID);
				items.addIdentifier(SELECT);
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(InputParameter expression) {
		// No content assist can be provider for an input parameter
		super.visit(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(Join expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();
		String identifier = expression.getIdentifier();

		// Within "<join>"
		if (isPositionWithin(position, identifier)) {

			// Add join identifiers
			items.addIdentifier(JOIN);
			items.addIdentifier(INNER_JOIN);
			items.addIdentifier(LEFT_JOIN);
			items.addIdentifier(LEFT_OUTER_JOIN);

			// Only add the join fetch identifiers if there is no AS or identification variable
			// otherwise the expression would become invalid
			if (!expression.hasAs() &&
			    !expression.hasIdentificationVariable()) {

				items.addIdentifier(JOIN_FETCH);
				items.addIdentifier(INNER_JOIN_FETCH);
				items.addIdentifier(LEFT_JOIN_FETCH);
				items.addIdentifier(LEFT_OUTER_JOIN_FETCH);
			}
		}
		// After "<join> "
		else if (expression.hasSpaceAfterJoin()) {
			int length = identifier.length() + SPACE_LENGTH;

			// Right after "<join> "
			if (position == length) {
				addLeftRangeIdentificationVariables();
			}

			// After "join association path expression "
			if (expression.hasJoinAssociationPath() &&
			    expression.hasSpaceAfterJoinAssociation()) {

				length += length(expression.getJoinAssociationPath()) + SPACE_LENGTH;

				// Right after "join association path expression "
				if (isPositionWithin(position, length, AS)) {
					items.addIdentifier(AS);
				}
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(JoinFetch expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();

		// Within "<join fetch>"
		if (isPositionWithin(position, expression.getIdentifier())) {

			// Add join identifiers
			items.addIdentifier(JOIN);
			items.addIdentifier(INNER_JOIN);
			items.addIdentifier(LEFT_JOIN);
			items.addIdentifier(LEFT_OUTER_JOIN);

			// Add the join fetch identifiers
			items.addIdentifier(JOIN_FETCH);
			items.addIdentifier(INNER_JOIN_FETCH);
			items.addIdentifier(LEFT_JOIN_FETCH);
			items.addIdentifier(LEFT_OUTER_JOIN_FETCH);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(JPQLExpression expression) {

		// Prevent infinite recursion
		if (isLocked(expression)) {
			return;
		}

		int position = position(expression);
		Expression queryStatement = expression.getQueryStatement();
		Expression unknownEndingExpression = expression.getUnknownEndingStatement();

		// At the beginning of the expression
		if (position - corrections.peek() == 0) {
			if (corrections.peek() == 0) {
				addPossibleChoice(Expression.SELECT);
				addPossibleChoice(Expression.UPDATE);
				addPossibleChoice(Expression.DELETE_FROM);
			}
			// The query is not valid, it does not even have the beginning of a
			// valid query, so we use the entire text to check what is valid
			else {
				String text = expression.toParsedText();
				String word = text.substring(0, position);

				addPossibleChoice(Expression.SELECT,      word);
				addPossibleChoice(Expression.UPDATE,      word);
				addPossibleChoice(Expression.DELETE_FROM, word);
			}
		}
		else if (queryPosition.getExpression() == unknownEndingExpression &&
		         position > length(queryStatement)) {

			virtualSpace = position(unknownEndingExpression);
			lockedExpression = expression;
			corrections.add(0);
			String oldWord = word;

			if (word.length() == 0) {
				word = unknownEndingExpression.toParsedText().substring(0, virtualSpace);
			}

			Expression childExpression = lastLeaf(queryStatement);
			queryPosition.addPosition(childExpression, length(childExpression));
			childExpression.accept(this);

			word = oldWord;
			virtualSpace = 0;
			lockedExpression = null;
			corrections.pop();
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(KeyExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(KeywordExpression expression) {
		// NOTE: MANUALLY TESTED
		corrections.add(position(expression));
		super.visit(expression);
		corrections.pop();

		int position = position(expression) - corrections.peek();;

		// Within the identifier
		if (isPositionWithin(position, TRUE)  ||
		    isPositionWithin(position, FALSE) ||
		    isPositionWithin(position, NULL)) {

			items.addIdentifier(TRUE);
			items.addIdentifier(FALSE);
			items.addIdentifier(NULL);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(LengthExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(LikeExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();
		int length = 0;

		if (expression.hasStringExpression()) {
			length += length(expression.getStringExpression()) + SPACE_LENGTH;
		}

		// Within "LIKE" or "NOT LIKE"
		if (isPositionWithin(position, length, expression.getIdentifier())) {
			items.addIdentifier(LIKE);
			items.addIdentifier(NOT_LIKE);
		}
		// After "LIKE " or "NOT LIKE "
		else if (expression.hasSpaceAfterLike()) {
			length += expression.getIdentifier().length() + SPACE_LENGTH;

			// After "<pattern value> "
			if (expression.hasPatternValue() &&
			    expression.hasSpaceAfterPatternValue()) {

				length += length(expression.getPatternValue()) + SPACE_LENGTH;

				// Within "ESCAPE"
				if (isPositionWithin(position, length, ESCAPE)) {
					items.addIdentifier(ESCAPE);
				}
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(LocateExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitEncapsulatedExpression(expression, LOCATE, StringPrimaryBNF.ID);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(LowerExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(MaxFunction expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAggregateFunction(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(MinFunction expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAggregateFunction(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ModExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitEncapsulatedExpression(expression, MOD, SimpleArithmeticExpressionBNF.ID);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(MultiplicationExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitArithmeticExpression(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(NotExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();

		// Within "NOT
		if (isPositionWithin(position, NOT)) {
			items.addIdentifier(NOT);

			// Also add the negated JPQL identifiers
			if (!expression.hasExpression()) {
				items.addIdentifier(NOT_BETWEEN);
				items.addIdentifier(NOT_EXISTS);
				items.addIdentifier(NOT_IN);
				items.addIdentifier(NOT_LIKE);
				items.addIdentifier(NOT_MEMBER);
				items.addIdentifier(NOT_MEMBER_OF);
			}
		}
		// After "NOT "
		else if (expression.hasSpaceAfterNot()) {
			int length = NOT.length() + SPACE_LENGTH;

			// Right after "NOT "
			if (position == length) {
				items.addIdentifier(NOT_BETWEEN);
				items.addIdentifier(NOT_EXISTS);
				items.addIdentifier(NOT_IN);
				items.addIdentifier(NOT_LIKE);
				items.addIdentifier(NOT_MEMBER);
				items.addIdentifier(NOT_MEMBER_OF);
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(NullComparisonExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();
		int length = 0;

		if (expression.hasExpression()) {
			length += length(expression.getExpression()) + SPACE_LENGTH;
		}

		// Within "IS NULL" or "IS NOT NULL"
		if (isPositionWithin(position, length, expression.getIdentifier().name())) {
			items.addIdentifier(IS_NULL);
			items.addIdentifier(IS_NOT_NULL);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(NullIfExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitEncapsulatedExpression(expression, NULLIF, ScalarExpressionBNF.ID);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(NumericLiteral expression) {
		// No content assist can be provider for a numerical value
		super.visit(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ObjectExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(OrderByClause expression) {
		// NOTE: MANUALLY TESTED
		if (!isLocked(expression)) {
			super.visit(expression);
			visitClause(expression, ORDER_BY, expression.hasSpaceAfterOrderBy(), orderByClauseHelper());
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(OrderByItem expression) {

		super.visit(expression);
		int position = position(expression);
		int length   = length(expression);

		if ((position - corrections.peek() == length) && (expression.getOrdering() == Ordering.DEFAULT) ||
		    virtualSpace > 0 && -corrections.peek() + SPACE_LENGTH == length) {

			addPossibleChoice(ASC);
			addPossibleChoice(DESC);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(OrExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitLogicalExpression(expression, OR);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(RangeVariableDeclaration expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();

		// After "<abstract schema name> "
		if (expression.hasAbstractSchemaName() &&
		    expression.hasSpaceAfterAbstractSchemaName()) {

			int length = length(expression.getAbstractSchemaName()) + SPACE_LENGTH;

			// Right after "<abstract schema name> "
			if (isPositionWithin(position, length, AS)) {
				addPossibleChoice(AS);
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ResultVariable expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();
		int length = 0;

		if (expression.hasSelectExpression()) {
			length += length(expression.getSelectExpression()) + SPACE_LENGTH;
		}

		// Within "AS"
		if (isPositionWithin(position, length, AS)) {
			items.addIdentifier(AS);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SelectClause expression) {
		// NOTE: MANUALLY TESTED
		if (!isLocked(expression)) {
			super.visit(expression);
			visitAbstractSelectClause(expression);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SelectStatement expression) {
		// NOTE: MANUALLY TESTED
		if (!isLocked(expression)) {
			super.visit(expression);
			visitAbstractSelectStatement(expression);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SimpleFromClause expression) {
		// NOTE: MANUALLY TESTED
		if (!isLocked(expression)) {
			super.visit(expression);
			visitClause(expression, FROM, expression.hasSpaceAfterFrom(), fromClauseHelper());
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SimpleSelectClause expression) {
		// NOTE: MANUALLY TESTED
		if (!isLocked(expression)) {
			super.visit(expression);
			visitAbstractSelectClause(expression);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SimpleSelectStatement expression) {
		if (!isLocked(expression)) {
			// Don't continue traversing the parent hierarchy because a subquery
			// will handle all the possible choices
			visitAbstractSelectStatement(expression);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SizeExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SqrtExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(StateFieldPathExpression expression) {
		// NOTE: MANUALLY TESTED
		corrections.add(position(expression));
		super.visit(expression);
		corrections.pop();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(StringLiteral expression) {
		// No content assist required
		super.visit(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SubExpression expression) {
		// NOTE: MANUALLY TESTED
		corrections.add(position(expression));
		super.visit(expression);
		corrections.pop();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SubtractionExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitArithmeticExpression(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SubstringExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitEncapsulatedExpression(expression, SUBSTRING, StringPrimaryBNF.ID);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SumFunction expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAggregateFunction(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(TreatExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();

		// Within "TREAT"
		if (isPositionWithin(position, TREAT)) {
			if (isValidVersion(TREAT)) {
				items.addIdentifier(TREAT);
			}
		}
		// After "TREAT("
		else if (expression.hasLeftParenthesis()) {
			int length = TREAT.length() + 1;

			// Right after "TREAT("
			if (position == length) {
				addIdentificationVariables(IdentificationVariableType.LEFT);
			}

			// After "<collection-valued path expression> "
			if (expression.hasExpression() &&
			    expression.hasSpaceAfterExpression()) {

				length += length(expression.getExpression()) + SPACE_LENGTH;

				// Within "AS"
				if (isPositionWithin(position, length, AS)) {
					items.addIdentifier(AS);

					// If the entity type is not specified, then we can add
					// the possible abstract schema names
					if (!expression.hasEntityType()) {
						// TODO: Filter to only have the valid abstract schema names
						addAbstractSchemaNames();
					}
				}
			}

			// After "AS "
			if (expression.hasAs() &&
			    expression.hasSpaceAfterAs()) {

				length += AS.length() + SPACE_LENGTH;

				// Right after "AS "
				if (position == length) {
					// TODO: Filter to only have the valid abstract schema names
					addAbstractSchemaNames();
				}
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(TrimExpression expression) {

		super.visit(expression);
		int position = position(expression);

		// TRIM
		if (isPositionWithin(position, TRIM)) {
			items.addIdentifier(TRIM);
		}
		// After '('
		else if (position - corrections.peek() == position(expression, LEFT_PARENTHESIS) + SPACE_LENGTH) {
			addPossibleChoice(BOTH);
			addPossibleChoice(LEADING);
			addPossibleChoice(TRAILING);
			addIdentificationVariables();
			addAllPossibleFunctions(StringPrimaryBNF.ID);
		}
		else {
			StringBuilder writer = new StringBuilder();

			// 'TRIM'
			writer.append(TRIM);

			// '('
			if (expression.hasLeftParenthesis()) {
				writer.append(LEFT_PARENTHESIS);
			}

			// Trim specification
			if (expression.hasSpecification()) {
				writer.append(expression.getSpecification().name());
			}

			if (expression.hasSpaceAfterSpecification()) {
				writer.append(SPACE);
			}

			// Trim character
			if (expression.hasTrimCharacter()) {
				writer.append(expression.getTrimCharacter());
			}

			if (expression.hasSpaceAfterTrimCharacter()) {
				writer.append(SPACE);
			}

			// After the character
			if (position - corrections.peek() == writer.length()) {
				addPossibleChoice(FROM);

				if (!expression.hasFrom()) {
					addIdentificationVariables();
					addAllPossibleFunctions(StringPrimaryBNF.ID);
				}
			}

			if (expression.hasFrom()) {
				writer.append(FROM);
			}

			if (expression.hasSpaceAfterFrom()) {
				writer.append(SPACE);
			}

			// After the FROM
			if (position - corrections.peek() == writer.length()) {
				addIdentificationVariables();
				addAllPossibleFunctions(StringPrimaryBNF.ID);
			}

			if (expression.hasExpression()) {
				writer.append(expression.getExpression());

				if (position - corrections.peek() - virtualSpace == writer.length() &&
				    !expression.hasTrimCharacter() &&
				    !expression.hasFrom()) {

					addPossibleChoice(FROM);
				}
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(TypeExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(UnknownExpression expression) {
		// NOTE: MANUALLY TESTED
		corrections.add(position(expression));
		super.visit(expression);
		corrections.pop();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(UpdateClause expression) {

		super.visit(expression);
		int position = position(expression);

		// Within "UPDATE"
		if (isPositionWithin(position, UPDATE)) {
			items.addIdentifier(UPDATE);
		}
		// After "UPDATE "
		else if (position - corrections.peek() == UPDATE.length() + SPACE_LENGTH) {
			addAbstractSchemaNames();
		}
		else {
			// Rebuild the query so we know how to match the cursor within
			// the UPDATE clause
			StringBuilder sb = new StringBuilder();
			sb.append(UPDATE);

			if (expression.hasSpaceAfterUpdate()) {
				sb.append(SPACE);
			}

			sb.append(expression.getRangeVariableDeclaration().toParsedText());

			if (expression.hasSpaceAfterRangeVariableDeclaration()) {
				sb.append(SPACE);

				if (position - corrections.peek() == sb.length()) {
					addPossibleChoice(SET);
				}
			}

			if (expression.hasSet()) {
				sb.append(SET);
			}

			// Within "SET"
			if (position - corrections.peek() == sb.length()) {
				// Before we add SET, we need to make sure the range variable
				// declaration is complete, if for instance it does not have the
				// identification variable, then SET should be a valid choice
				RangeVariableDeclarationCompleteness completeness = new RangeVariableDeclarationCompleteness();
				expression.getRangeVariableDeclaration().accept(completeness);

				if (completeness.complete) {
					addPossibleChoice(SET);
				}
			}
			else {
				if (expression.hasSpaceAfterSet()) {
					sb.append(SPACE);
				}

				// After "SET "
				if (position - corrections.peek() == sb.length()) {
					addIdentificationVariables();
				}
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(UpdateItem expression) {

		super.visit(expression);
		int position = position(expression);

		if (position - corrections.peek() == 0) {
			addIdentificationVariables();
		}
		else {
			StringBuilder sb = new StringBuilder();
			sb.append(expression.getStateFieldPathExpression().toParsedText());

			if ((position == sb.length()) && !expression.hasSpaceAfterStateFieldPathExpression()) {
				items.addIdentifier(EQUAL);
			}
			else if (expression.hasSpaceAfterStateFieldPathExpression()) {
				sb.append(SPACE);

				if (position == sb.length()) {
					items.addIdentifier(EQUAL);
				}
			}

			if (expression.hasEqualSign()) {
				sb.append(EQUAL);

				if (position == sb.length()) {
					addAllPossibleIdentifiers(NewValueBNF.ID);
				}
			}

			if (expression.hasSpaceAfterEqualSign()) {
				sb.append(SPACE);
			}

			if (position - corrections.peek() == sb.length()) {
				addAllPossibleIdentifiers(NewValueBNF.ID);
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(UpdateStatement expression) {

		// Prevent infinite recursion
		if (!isLocked(expression)) {
			return;
		}

		super.visit(expression);

		int position           = position(expression);
		int updateClauseLength = length(expression.getUpdateClause());
		int whereClauseLength  = length(expression.getWhereClause());

		int updateClauseSpace  = expression.hasSpaceAfterUpdateClause() ? 1 : 0;

		//
		// UPDATE
		//
		int length = updateClauseLength + updateClauseSpace;

		// The cursor is right after "UPDATE "
		if (position == UPDATE.length() + SPACE_LENGTH) {
			addAbstractSchemaNames();
		}

		// The cursor is after the UPDATE clause
		if ((position == length) && (expression.getUpdateClause().toParsedText().endsWith(" ") || updateClauseSpace > 0)) {
			TrailingCompletenessVisitor visitor = new TrailingCompletenessVisitor();
			expression.getUpdateClause().accept(visitor);

			if (visitor.complete) {
				addPossibleChoice(WhereClause.WHERE);
			}

			lockedExpression = expression;

			if (virtualSpace == 0) {
				virtualSpace = 1;
			}

			// First, dig into the leaf expression
			Expression childExpression = lastLeaf(expression.getUpdateClause());
			Integer oldPosition = queryPosition.getPosition(childExpression);
			int oldPositionInCollection = positionInCollection;
			queryPosition.addPosition(childExpression, childExpression.toParsedText().length());
			childExpression.accept(this);

			if (oldPosition != null) {
				queryPosition.addPosition(childExpression, oldPosition);
			}
			else {
				queryPosition.removePosition(childExpression);
			}

			positionInCollection = oldPositionInCollection;
			virtualSpace = 0;
			lockedExpression = null;
		}

		//
		// WHERE
		//
		length += whereClauseLength;

		// The cursor is after the WHERE clause
		if (position == length) {
			lockedExpression = expression;

			if (virtualSpace == 0) {
				virtualSpace = 1;
			}

			// First, dig into the leaf expression
			Expression childExpression = expression.getWhereClause();
			int previousPosition = position(childExpression);
			queryPosition.addPosition(childExpression, whereClauseLength + SPACE_LENGTH);
			childExpression.accept(this);
			queryPosition.addPosition(childExpression, previousPosition);

			virtualSpace = 0;
			lockedExpression = expression;
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(UpperExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ValueExpression expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		visitAbstractSingleEncapsulatedExpression(expression, true);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(WhenClause expression) {
		// NOTE: MANUALLY TESTED
		super.visit(expression);
		int position = position(expression) - corrections.peek();

		// Within "WHEN"
		if (isPositionWithin(position, WHEN)) {
			items.addIdentifier(WHEN);
		}
		// After "WHEN "
		else if (expression.hasSpaceAfterWhen()) {
			int length = WHEN.length() + SPACE_LENGTH;

			// Right after "WHEN "
			if (position == length) {
				addIdentificationVariables();
				addAllPossibleFunctions(InternalWhenClauseBNF.ID);
			}
			else {
				length += length(expression.getWhenExpression());

				// After "WHEN <expression> " => THEN
				if (expression.hasSpaceAfterWhenExpression()) {
					length++;

					// Right after "WHEN <expression> " => THEN
					if (position == length) {
						items.addIdentifier(THEN);
					}
					else if (expression.hasThen()) {
						// Within "THEN"
						if (isPositionWithin(position, length, THEN)) {
							items.addIdentifier(THEN);
						}
						else {
							length += THEN.length();

							// After "WHEN <expression> THEN "
							if (expression.hasSpaceAfterThen()) {
								length++;

								// Right after "WHEN <expression> THEN "
								if (position == length) {
									addScalarExpressionChoices();
								}
							}
						}
					}
				}
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(WhereClause expression) {
		// NOTE: MANUALLY TESTED
		if (!isLocked(expression)) {
			super.visit(expression);
			visitClause(expression, WHERE, expression.hasSpaceAfterIdentifier(), whereClauseHelper());
		}
	}

	private void visitAbstractConditionalClause(AbstractConditionalClause expression) {

		int globalPosition = position(expression.getRoot());

		// If there is already a conditional expression, check to see if
		// it can be wrapped to become a compound expression, example:
		// "AVG(e.age) " could become "AVG(e.age) BETWEEN 21 AND 64", which
		// means BETWEEN can be a possible choice
		if (expression.hasConditionalExpression()) {
			CompoundableVisitor compoundableVisitor = new CompoundableVisitor();
			expression.getConditionalExpression().accept(compoundableVisitor);

			if (compoundableVisitor.compoundable) {
				addAllPossibleCompoundFunctions(ConditionalExpressionBNF.ID, globalPosition);
			}

			// Now check for aggregate functions
			TrailingCompletenessVisitor completenessVisitor = new TrailingCompletenessVisitor();
			expression.getConditionalExpression().accept(completenessVisitor);

			if (completenessVisitor.complete) {
				addAllPossibleAggregates(ConditionalExpressionBNF.ID);
			}
		}
		else {
			addAllPossibleFunctions(ConditionalExpressionBNF.ID);
		}
	}

	private void visitAbstractSelectClause(AbstractSelectClause expression) {

		int position = position(expression);

		// Within "SELECT"
		if (isPositionWithin(position, SELECT)) {
			items.addIdentifier(SELECT);
		}
		// After "SELECT "
		else if (expression.hasSpaceAfterSelect()) {
			int length = SELECT.length() + SPACE_LENGTH;

			// Within "DISTINCT"
			if (expression.hasDistinct() &&
			    isPositionWithin(position, length, DISTINCT)) {

				items.addIdentifier(DISTINCT);
			}
			// After "DISTINCT "
			else {
				if (expression.hasDistinct()) {
					length += DISTINCT.length();

					if (expression.hasSpaceAfterDistinct()) {
						length++;
					}
				}

				// Right after "SELECT " or after "DISTINCT "
				if (position == length) {
					if (!expression.hasDistinct()) {
						addPossibleChoice(DISTINCT);
					}
					addIdentificationVariables();
					addAllPossibleFunctions(SelectItemBNF.ID);
				}
				// Somewhere in the clause's expression
				else {
					length += length(expression.getSelectExpression());

					// At the end of the clause's expression
					if (position <= length) {
						addSelectExpressionChoices(expression, length);
					}
				}
			}
		}
	}

	private void visitAbstractSelectStatement(AbstractSelectStatement expression) {

		lockedExpression = expression;

		int position = position(expression) - corrections.peek();
		int length = SELECT.length() + SPACE_LENGTH;
		int previousLength = 0;

		// Right after "SELECT "
//		if (position == length) {
//			expression.getSelectClause().accept(this);
//		}
		// After "SELECT " and within the select expression or right before the FROM clause
//		else {
			AbstractSelectClause selectClause = expression.getSelectClause();

			if (selectClause.hasDistinct()) {
				length += DISTINCT.length();

				if (selectClause.hasSpaceAfterDistinct()) {
					length++;
				}
			}

			previousLength = length;
			length = length(selectClause);

			// Within the select expression
			if ((position >= previousLength) && (position < length)) {
				selectClause.accept(this);
			}
			// Right after the select expression, the space is owned by the select statement
			else if (expression.hasSpaceAfterSelect() &&
			         position == length + SPACE_LENGTH) {

				virtualSpace = SPACE_LENGTH;
				corrections.add(-SELECT.length() - 2);

				selectClause.accept(this);

				corrections.pop();
				virtualSpace = 0;
			}
//		}

		if (expression.hasSpaceAfterSelect()) {
			length++;
		}

		// Right after "FROM "
		if (position == length) {
			expression.getFromClause().accept(this);
		}
		// Check for within the from clause
		else {
			length = length(expression.getFromClause());

			// Within the from clause
			if (position <= length) {
				expression.getFromClause().accept(this);
			}
			// Right after the from clause, the space is owned by the select statement
			else if (expression.hasSpaceAfterFrom() &&
			         position == length + SPACE_LENGTH) {

				corrections.push(- (length + 1));
				expression.getFromClause().accept(this);
				corrections.pop();
			}
		}

		lockedExpression = null;
	}

	/**
	 * Adds the possible choices for the given {@link AbstractSingleEncapsulatedExpression expression}
	 * based on the location of the cursor and the content of the expression.
	 *
	 * @param expression The {@link AbstractSingleEncapsulatedExpression expression} being visited
	 * @param identificationVariablesAllowed Determines whether the identification variables should
	 * be added as valid choices after the left parenthesis
	 */
	private void visitAbstractSingleEncapsulatedExpression(AbstractSingleEncapsulatedExpression expression,
	                                                       boolean identificationVariablesAllowed) {

		visitAbstractSingleEncapsulatedExpression(
			expression,
			identificationVariablesAllowed,
			expression.getIdentifier()
		);
	}

	/**
	 * Adds the possible choices for the given {@link AbstractSingleEncapsulatedExpression expression}
	 * based on the location of the cursor and the content of the expression.
	 *
	 * @param expression The {@link AbstractSingleEncapsulatedExpression expression} being visited
	 * @param identificationVariablesAllowed Determines whether the identification variables should
	 * be added as valid choices after the left parenthesis
	 * @param expressionIdentifiers Sometimes the expression may have more than one possible identifier,
	 * such as <b>ALL</b>, <b>ANY</b> and <b>SOME</b> are a possible JPQL identifier for a single
	 * expression ({@link AllOrAnyExpression}
	 */
	private void visitAbstractSingleEncapsulatedExpression(AbstractSingleEncapsulatedExpression expression,
	                                                       boolean identificationVariablesAllowed,
	                                                       String... expressionIdentifiers) {

		int position = position(expression) - corrections.peek();
		String actualIdentifier = expression.getIdentifier();
		boolean added = false;

		for (String identifier : expressionIdentifiers) {

			// Within the identifier
			if (isPositionWithin(position, actualIdentifier)) {
				items.addIdentifier(identifier);
			}
			// Right after "<identifier>("
			else if (expression.hasLeftParenthesis()) {
				int length = identifier.length() + 1 /* '(' */;

				if (!added && (position == length)) {
					added = true;

					if (identificationVariablesAllowed) {
						addIdentificationVariables();
					}

					JPQLQueryBNF queryBNF = expression.encapsulatedExpressionBNF();
					addAllPossibleFunctions(queryBNF);
					addAllPossibleClauses(queryBNF);
				}
			}
		}
	}

	private void visitAggregateFunction(AggregateFunction expression) {

		int position = position(expression) - corrections.peek();
		String identifier = expression.getIdentifier();

		// Within "<identifier>"
		if (isPositionWithin(position, identifier)) {
			items.addIdentifier(identifier);
		}
		// After "<identifier>("
		else if (expression.hasLeftParenthesis()) {
			int length = identifier.length() + 1 /* '(' */;
			boolean hasDistinct = expression.hasDistinct();

			// Within "DISTINCT"
			if (hasDistinct && isPositionWithin(position, length, DISTINCT) ) {
				addPossibleChoice(DISTINCT);
			}
			// After "("
			else {
				if (hasDistinct && expression.hasSpaceAfterDistinct()) {
					length = DISTINCT.length() + SPACE_LENGTH;
				}

				// Right after "(" or right after "(DISTINCT "
				if (position == length) {
					if (!hasDistinct) {
						addPossibleChoice(DISTINCT);
					}
					addIdentificationVariables();
					addAllPossibleFunctions(expression.encapsulatedExpressionBNF());
				}
			}
		}
	}

	private void visitArithmeticExpression(ArithmeticExpression expression) {

		int position = position(expression) - corrections.peek();
		int length = 0;

		if (expression.hasLeftExpression()) {
			length += length(expression.getLeftExpression()) + SPACE_LENGTH;
		}

		// Within the arithmetic sign
		if (isPositionWithin(position, length, PLUS)) {
			addAllPossibleAggregates(expression.getQueryBNF());
		}
		// After the arithmetic sign, with or without the space
		else if (expression.hasSpaceAfterIdentifier()) {
			length += 2;

			// Right after the space
			if ((position == length) && (positionInCollection == -1)) {
				addIdentificationVariables();
				addAllPossibleFunctions(expression.rightExpressionBNF(), position);
			}
		}
	}

	private <T extends AbstractExpression> void visitClause(T expression,
	                                                        String identifier,
	                                                        boolean hasSpaceAfterIdentifier,
	                                                        ClauseHelper<T> helper) {

		int position = position(expression) - corrections.peek();

		// Within "<identifier>"
		if (isPositionWithin(position, identifier)) {
			items.addIdentifier(identifier);
		}
		// After "<identifier> "
		else if (hasSpaceAfterIdentifier) {
			int length = identifier.length() + SPACE_LENGTH;

			// Right after "<identifier> "
			if (position == length) {
				helper.addChoices(expression);
			}
			// Somewhere in the clause's expression
			else {
				length += length(helper.getClauseExpression(expression));

				// At the end of the clause's expression
				if ((position == length) && (corrections.peek() > 0)) {
					helper.addChoices(expression);
				}
			}
		}
	}

	/**
	 * Adds the possible choices for the given {@link AbstractSingleEncapsulatedExpression expression}
	 * based on the location of the cursor and the content of the expression.
	 *
	 * @param expression The {@link AbstractSingleEncapsulatedExpression expression} being visited
	 * @param expressionIdentifiers Sometimes the expression may have more than one possible identifier,
	 * such as <b>ALL</b>, <b>ANY</b> and <b>SOME</b> are a possible JPQL identifier for a single
	 * expression ({@link AllOrAnyExpression}
	 */
	private void visitEncapsulatedExpression(AbstractEncapsulatedExpression expression,
	                                         String identifier,
	                                         String jpqlQueryBNF) {

		int position = position(expression) - corrections.peek();

		// Within the identifier
		if (isPositionWithin(position, identifier)) {
			items.addIdentifier(identifier);
		}
		// Right after "<identifier>("
		else if (expression.hasLeftParenthesis()) {
			int length = identifier.length() + 1 /* '(' */;

			if (position == length) {
				addIdentificationVariables();
				addAllPossibleFunctions(jpqlQueryBNF);
			}
		}
	}

	private void visitEncapsulatedIdentificationVariable(EncapsulatedIdentificationVariableExpression expression) {

		// Find the FROM clause
		FromClauseFinder fromClauseFinder = new FromClauseFinder();
		expression.accept(fromClauseFinder);

		// Collect the identification variables used to identify collection-valued
		// members from the FROM clause
		IdentificationVariablesFromCollectionDeclarationVisitor visitor =
			new IdentificationVariablesFromCollectionDeclarationVisitor(expression);

		if (fromClauseFinder.fromClause != null) {
			fromClauseFinder.fromClause.accept(visitor);
		}

		for (String item : visitor.items) {
			addPossibleChoice(item);
		}
	}

	private void visitLogicalExpression(LogicalExpression expression, String identifier) {

		int position = position(expression);
		int length = 0;

		if (expression.hasLeftExpression()) {
			length += length(expression.getLeftExpression()) + 1;
		}

		// Within the identifier
		if (position - corrections.peek() >= length &&
		    position - corrections.peek() <= length + identifier.length()) {

			items.addIdentifier(identifier);
		}
		else {
			length += (expression.hasSpaceAfterIdentifier() ? 1 : 0);

			// After "<identifier> "
			if (position - corrections.peek() == length) {
				addIdentificationVariables();
				addAllPossibleFunctions(expression.rightExpressionBNF());
			}
		}
	}

	private ClauseHelper<WhereClause> whereClauseHelper() {
		if (whereClauseHelper == null) {
			whereClauseHelper = buildWhereClauseHelper();
		}
		return whereClauseHelper;
	}

	/**
	 * This visitor retrieves the abstract schema name.
	 */
	private class AbstractSchemaNameVisitor extends AbstractExpressionVisitor {

		/**
		 * The abstract schema name that is retrieved from
		 * {@link AbstractSchemaName} if it was visited.
		 */
		String abstractSchemaName;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AbstractSchemaName expression) {
			abstractSchemaName = expression.toParsedText();
		}
	}

	/**
	 * This helper is responsible to add the choices
	 */
	private interface ClauseHelper<T extends Expression> {

		/**
		 * Adds the possible choices at the given position.
		 *
		 * @param expression
		 */
		void addChoices(T expression);

		/**
		 * Returns the expression from the given clause.
		 *
		 * @param expression The clause for which its expression is needed
		 * @return The clause's expression
		 */
		Expression getClauseExpression(T expression);
	}

	private abstract class CompletenessVisitor extends AbstractExpressionVisitor {

		/**
		 * Determines whether an {@link Expression} that was visited is complete or if some part is
		 * missing.
		 */
		boolean complete;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression) {

			// • -1 means it's at the beginning of the CollectionExpression
			// • If the position in the collection is equal to the children count
			//   then the last expression is null like "..., "
			if (positionInCollection == -1 ||
			    positionInCollection == expression.childrenSize()) {

				complete = true;
			}
			else {
				AbstractExpression child = (AbstractExpression) expression.getChild(positionInCollection);

				// An empty expression is always complete
				if (child.isNull()) {
					complete = true;
				}
				else {
					int length = expression.toParsedText(positionInCollection).length();

					// The position is at the beginning of the child expression, that means
					// it's complete because we don't have to verify the child expression
					if (corrections.peek() == length) {
						int index = Math.max(0, positionInCollection - 1);
						complete = expression.hasComma(index);
					}
					// Dig into the child expression to check its status
					else {
						child.accept(this);
					}
				}
			}
		}
	}

	private class CompoundableVisitor extends AbstractExpressionVisitor {

		/**
		 * Determines if the {@link Expression} can be compounded, which means if it can be the left
		 * part of a compound expression.
		 */
		private boolean compoundable;

		private void checkCompleteness(Expression expression) {
			TrailingCompletenessVisitor visitor = new TrailingCompletenessVisitor();
			expression.accept(visitor);
			compoundable = visitor.complete;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AbsExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AdditionExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AndExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AvgFunction expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(BetweenExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression) {
			// A CollectionExpression here could mean the query is incomplete but
			// it could become compoundable
			int lastIndex = expression.childrenSize() - 1;
			expression.getChild(lastIndex).accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionMemberExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CountFunction expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DivisionExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression) {
			compoundable = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(LengthExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MaxFunction expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MinFunction expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ModExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MultiplicationExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NotExpression expression) {
			compoundable = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SizeExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SqrtExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(StateFieldPathExpression expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SumFunction expression) {
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(UnknownExpression expression) {
			// The unknown expression has "IS", which can be part
			// of a compound expression
			String text = expression.toParsedText();
			compoundable = NullComparisonExpression.IS.equalsIgnoreCase(text);
		}
	}

	/**
	 * Example: "DELETE FROM"
	 */
	private class DeleteClauseHelper implements ClauseHelper<DeleteClause> {

		/**
		 * {@inheritDoc}
		 */
		public void addChoices(DeleteClause expression) {
			addIdentificationVariables();
		}

		/**
		 * {@inheritDoc}
		 */
		public Expression getClauseExpression(DeleteClause expression) {
			return expression.getRangeVariableDeclaration();
		}
	}

	/**
	 * This {@link CompletenessVisitor} is used to check the completeness of the <b>FROM</b> clause's
	 * declaration. It helps {@link FromClauseHelper} to check if some choices can be added. For the
	 * <b>FROM</b> clause, the possible choices are the abstract schema names and the <b>IN</b>
	 * identifier.
	 */
	private class FromClauseCompletenessVisitor extends CompletenessVisitor {

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FromClause expression) {

			int position = position(expression);

			if (position == FROM.length() + SPACE_LENGTH) {
				complete = true;
			}
			else {
				expression.getDeclaration().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariableDeclaration expression) {

			// Example: "E"
			// Example: "Employee e"
			// Example: "Employee e "
			if (expression.hasRangeVariableDeclaration() &&
			   !expression.hasJoins())
			{
				expression.getRangeVariableDeclaration().accept(this);
			}
			else {
				complete = position(expression) < 1;
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NullExpression expression) {
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(RangeVariableDeclaration expression) {
			// Within "<abstract schema name>"
			int position = position(expression);
			complete = position >= 0 && position <= length(expression.getAbstractSchemaName());
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleFromClause expression) {

			int position = position(expression);

			if (position - corrections.peek() == FROM.length() + SPACE_LENGTH) {
				complete = true;
			}
			else {
				expression.getDeclaration().accept(this);
			}
		}
	}

	private class FromClauseFinder extends AbstractTraverseParentVisitor {

		/**
		 *
		 */
		private AbstractFromClause fromClause;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FromClause expression) {
			fromClause = expression;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(JPQLExpression expression) {
			expression.getQueryStatement().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SelectStatement expression) {
			expression.getFromClause().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleFromClause expression) {
			fromClause = expression;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleSelectStatement expression) {
			expression.getFromClause().accept(this);
		}
	}

	private class FromClauseHelper implements ClauseHelper<AbstractFromClause> {

		/**
		 * {@inheritDoc}
		 */
		public void addChoices(AbstractFromClause expression) {

			addAbstractSchemaNames();

			// With the correction, check to see if the possible identifiers (IN)
			// can be added and only if it's not the first item in the list
			if (positionInCollection > 0) {
				addAllPossibleIdentifiers(InternalFromClauseBNF.ID);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		public Expression getClauseExpression(AbstractFromClause expression) {
			return expression.getDeclaration();
		}
	}

	private class GroupByClauseCompletenessVisitor extends CompletenessVisitor {

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NullExpression expression) {
			complete = true;
		}
	}

	/**
	 * Example: "GROUP BY "
	 */
	private class GroupByClauseHelper implements ClauseHelper<GroupByClause> {

		/**
		 * {@inheritDoc}
		 */
		public void addChoices(GroupByClause expression) {
			addIdentificationVariables();
		}

		/**
		 * {@inheritDoc}
		 */
		public Expression getClauseExpression(GroupByClause expression) {
			return expression.getGroupByItems();
		}
	}

	private class HavingClauseCompletenessVisitor extends CompletenessVisitor {

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NullExpression expression) {
			complete = true;
		}
	}

	/**
	 * Example: "HAVING "
	 */
	private class HavingClauseHelper implements ClauseHelper<HavingClause> {

		/**
		 * {@inheritDoc}
		 */
		public void addChoices(HavingClause expression) {
			addIdentificationVariables();
			addAllPossibleFunctions(ConditionalExpressionBNF.ID);
		}

		/**
		 * {@inheritDoc}
		 */
		public Expression getClauseExpression(HavingClause expression) {
			return expression.getConditionalExpression();
		}
	}

	private class IdentificationVariableFromDeclarationVisitor extends AbstractExpressionVisitor {

		/**
		 * The identification variable names defined in the declaration expression.
		 */
		private final Set<String> identificationVariables;

		/**
		 * The identification variable names mapped to their abstract schema names.
		 */
		private final Map<String, String> rangeIdentificationVariables;

		/**
		 * The type of identification variables to retrieve, which helps to filter
		 * out those from a different declaration.
		 */
		private final IdentificationVariableType type;

		/**
		 * Creates a new <code>IdentificationVariableFromDeclarationVisitor</code>.
		 *
		 * @param parent The parent of this resolver, which is never <code>null</code>
		 * @param type The type of identification variables to retrieve, which helps to filter out
		 * those from a different declaration
		 */
		IdentificationVariableFromDeclarationVisitor(IdentificationVariableType type) {
			super();
			this.type = type;
			this.identificationVariables = new HashSet<String>();
			this.rangeIdentificationVariables = new HashMap<String, String>();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression) {
			for (Iterator<Expression> children = expression.children(); children.hasNext(); ) {
				children.next().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionMemberDeclaration expression) {

			if (type == IdentificationVariableType.COLLECTION || type == IdentificationVariableType.ALL) {
				IdentificationVariableVisitor visitor = new IdentificationVariableVisitor();
				expression.getIdentificationVariable().accept(visitor);
				String variableName = visitor.identificationVariableName;

				if (ExpressionTools.stringIsNotEmpty(variableName)) {
					identificationVariables.add(variableName);
				}
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DeleteClause expression) {
			expression.getRangeVariableDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DeleteStatement expression) {
			expression.getDeleteClause().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FromClause expression) {
			expression.getDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariableDeclaration expression) {
			expression.getRangeVariableDeclaration().accept(this);
			expression.getJoins().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(Join expression) {

			if (type == IdentificationVariableType.JOIN || type == IdentificationVariableType.ALL) {
				IdentificationVariableVisitor visitor = new IdentificationVariableVisitor();
				expression.getIdentificationVariable().accept(visitor);
				String variableName = visitor.identificationVariableName;

				if (ExpressionTools.stringIsNotEmpty(variableName)) {
					identificationVariables.add(variableName);
				}
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(JPQLExpression expression) {
			expression.getQueryStatement().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(RangeVariableDeclaration expression) {

			if (type == IdentificationVariableType.RANGE || type == IdentificationVariableType.ALL) {

				IdentificationVariableVisitor visitor1 = new IdentificationVariableVisitor();
				expression.getIdentificationVariable().accept(visitor1);
				String variableName = visitor1.identificationVariableName;

				if (ExpressionTools.stringIsNotEmpty(variableName)) {
					identificationVariables.add(variableName);

					AbstractSchemaNameVisitor visitor2 = new AbstractSchemaNameVisitor();
					expression.getAbstractSchemaName().accept(visitor2);
					String abstractSchemaName = visitor2.abstractSchemaName;

					if (ExpressionTools.stringIsNotEmpty(abstractSchemaName)) {
						rangeIdentificationVariables.put(variableName, abstractSchemaName);
					}
				}
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SelectStatement expression) {
			expression.getFromClause().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleFromClause expression) {
			expression.getDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleSelectStatement expression) {
			expression.getFromClause().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(UpdateClause expression) {
			expression.getRangeVariableDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(UpdateStatement expression) {
			expression.getUpdateClause().accept(this);
		}

	}

	private class IdentificationVariablesFromCollectionDeclarationVisitor extends AbstractExpressionVisitor {

		private boolean completed;
		private final Expression expression;
		private final List<String> items;

		IdentificationVariablesFromCollectionDeclarationVisitor(Expression expression) {
			super();

			this.expression = expression;
			this.items      = new ArrayList<String>();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression) {

			for (Iterator<Expression> children = expression.children(); children.hasNext(); ) {
				children.next().accept(this);
				if (completed) {
					break;
				}
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionMemberDeclaration expression) {

			if (expression.isAncestor(this.expression)) {
				completed = true;
			}

			if (!completed) {
				expression.getIdentificationVariable().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FromClause expression) {
			expression.getDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression) {

			String variableName = expression.toParsedText();

			if (ExpressionTools.stringIsNotEmpty(variableName)) {
				items.add(variableName);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariableDeclaration expression) {
			expression.getJoins().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(Join expression) {

			if (expression.isAncestor(this.expression)) {
				completed = true;
			}

			if (!completed) {
				expression.getIdentificationVariable().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(KeyExpression expression) {

			if (expression.isAncestor(this.expression)) {
				completed = true;
			}

			if (!completed) {
				expression.getExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleFromClause expression) {
			expression.getDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ValueExpression expression) {

			if (expression.isAncestor(this.expression)) {
				completed = true;
			}

			if (!completed) {
				expression.getExpression().accept(this);
			}
		}
	}

	enum IdentificationVariableType {
		ALL,
		COLLECTION,
		JOIN,
		LEFT,
		LEFT_RANGE,
		RANGE
	}

	/**
	 * This visitor retrieves the identification variable name.
	 */
	private class IdentificationVariableVisitor extends AbstractExpressionVisitor {

		/**
		 * The identification variable name that is retrieved from {@link IdentificationVariable} if
		 * it was visited.
		 */
		String identificationVariableName;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression) {
			identificationVariableName = expression.getText();
		}
	}

	private interface ISelectStatementHelper<T extends AbstractSelectStatement> {

		void addClauseAfterHavingClause();
		boolean hasSpaceAfterHavingClause(T expression);
	}

	/**
	 * Example: "ORDER BY "
	 */
	private class OrderByClauseHelper implements ClauseHelper<OrderByClause> {

		/**
		 * {@inheritDoc}
		 */
		public void addChoices(OrderByClause expression) {
			addIdentificationVariables();
		}

		/**
		 * {@inheritDoc}
		 */
		public Expression getClauseExpression(OrderByClause expression) {
			return expression.getOrderByItems();
		}
	}

	private class RangeVariableDeclarationCompleteness extends AbstractExpressionVisitor {

		/**
		 * Determines whether an {@link Expression} that was visited was complete or if there some
		 * parts are missing.
		 */
		protected boolean complete;

		/**
		 * The count determine how if the range variable declaration is complete.
		 * To be complete, the count has to be 2.
		 */
		private int count;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AbstractSchemaName expression) {
			count++;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression) {
			count++;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(RangeVariableDeclaration expression) {

			expression.getAbstractSchemaName().accept(this);
			expression.getIdentificationVariable().accept(this);

			// If the abstract schema name and identification variable are defined
			// then the count is 2, which means the range variable declaration is
			// complete. If it wasn't, then the visit would have gone in any other
			// expression and the count woudn't have increased to 2
			complete = (count == 2);
		}
	}

	/**
	 * This visitor checks the integrity of the select items.
	 * <p>
	 * The possible JPQL identifiers allowed in a SELECT expression as of JPA 2.0
	 * are:
	 * <ul>
	 * <li> *, /, +, -
	 * <li> ABS
	 * <li> AVG
	 * <li> CASE
	 * <li> COALESCE
	 * <li> CONCAT
	 * <li> COUNT
	 * <li> CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, SQL date
	 * <li> ENTRY
	 * <li> FUNC
	 * <li> INDEX
	 * <li> KEY
	 * <li> LENGTH
	 * <li> LOCATE
	 * <li> LOWER
	 * <li> MAX
	 * <li> MIN
	 * <li> MOD
	 * <li> NEW
	 * <li> NULL
	 * <li> NULLIF
	 * <li> OBJECT
	 * <li> SIZE
	 * <li> SQRT
	 * <li> SUBSTRING
	 * <li> SUM
	 * <li> TRIM
	 * <li> TRUE, FALSE
	 * <li> TYPE
	 * <li> UPPER
	 * <li> VALUE
	 * </ul>
	 */
	private class SelectClauseCompletenessVisitor extends CompletenessVisitor {

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AbsExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AdditionExpression expression) {
			visitArithmeticExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AvgFunction expression) {
			visitAggregateFunction(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CaseExpression expression) {
			complete = expression.hasEnd();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CoalesceExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression) {

			// "SELECT e," is complete
			if (expression.endsWithComma()) {
				complete = true;
			}

			int lastIndex = expression.childrenSize() - 1;
			AbstractExpression child = (AbstractExpression) expression.getChild(lastIndex);

			// The collection ends with an empty element, that's not complete
			if (child.isNull()) {
				complete = false;
			}
			else {
				int length = expression.toParsedText(positionInCollection).length();

				// The position is at the beginning of the child expression, that means
				// it's complete because we don't have to verify the child expression
				if (corrections.peek() == length) {
					int index = Math.max(0, positionInCollection - 1);
					complete = expression.hasComma(index);
				}
				// Dig into the child expression to check its status
				else {
					child.accept(this);
				}
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ConcatExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ConstructorExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CountFunction expression) {
			visitAggregateFunction(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DateTime expression) {
			// Always complete if CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP
			// or if the JDBC escape syntax ends with '}'
			complete = expression.isJDBCDate() ? expression.toParsedText().endsWith("}") : true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DivisionExpression expression) {
			visitArithmeticExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(EntryExpression expression) {
			visitEncapsulatedIdentificationVariableExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FuncExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression) {
			// Always complete
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IndexExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(KeyExpression expression) {
			visitEncapsulatedIdentificationVariableExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(KeywordExpression expression) {
			// Always complete
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(LengthExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(LocateExpression expression) {
			visitAbstractTripleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(LowerExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MaxFunction expression) {
			visitAggregateFunction(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MinFunction expression) {
			visitAggregateFunction(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ModExpression expression) {
			visitAbstractDoubleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MultiplicationExpression expression) {
			visitArithmeticExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NullExpression expression) {
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NullIfExpression expression) {
			visitAbstractDoubleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ObjectExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ResultVariable expression) {
			complete = expression.hasResultVariable();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SelectClause expression) {

			int position = position(expression);

			if (position == SELECT.length() + SPACE_LENGTH) {
				complete = true;
			}
			else {
				expression.getSelectExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleSelectClause expression) {
			expression.getSelectExpression().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SizeExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SqrtExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(StateFieldPathExpression expression) {
			// Always complete, even if it ends with a dot
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SubtractionExpression expression) {
			visitArithmeticExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SubstringExpression expression) {
			visitAbstractTripleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SumFunction expression) {
			visitAggregateFunction(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(TrimExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(TypeExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(UpperExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ValueExpression expression) {
			visitEncapsulatedIdentificationVariableExpression(expression);
		}

		private void visitAbstractDoubleEncapsulatedExpression(AbstractDoubleEncapsulatedExpression expression) {
			visitAbstractEncapsulatedExpression(expression);
		}

		private void visitAbstractEncapsulatedExpression(AbstractEncapsulatedExpression expression) {
			// If ')' is present, then anything can be added after
			complete = expression.hasRightParenthesis();
		}

		private void visitAbstractSingleEncapsulatedExpression(AbstractSingleEncapsulatedExpression expression) {
			visitAbstractEncapsulatedExpression(expression);
		}

		private void visitAbstractTripleEncapsulatedExpression(AbstractTripleEncapsulatedExpression expression) {
			visitAbstractEncapsulatedExpression(expression);
		}

		private void visitAggregateFunction(AggregateFunction expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		private void visitArithmeticExpression(ArithmeticExpression expression) {
			expression.getRightExpression().accept(this);
		}

		private void visitEncapsulatedIdentificationVariableExpression(EncapsulatedIdentificationVariableExpression expression) {
			visitAbstractSingleEncapsulatedExpression(expression);
		}
	}

	private class SimpleSelectStatementHelper implements ISelectStatementHelper<SimpleSelectStatement> {

		/**
		 * {@inheritDoc}
		 */
		public void addClauseAfterHavingClause() {
		}

		/**
		 * {@inheritDoc}
		 */
		public boolean hasSpaceAfterHavingClause(SimpleSelectStatement expression) {
			return false;
		}
	}

	private class SubqueryVisitor extends AbstractTraverseParentVisitor {

		private SimpleSelectStatement expression;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleSelectStatement expression) {
			this.expression = expression;
		}
	}

	private class TrailingCompletenessVisitor extends CompletenessVisitor {

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AbsExpression expression) {
			complete = expression.hasRightParenthesis();
		}
		@Override
		public void visit(AbstractSchemaName expression) {
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AdditionExpression expression) {

			complete = expression.hasRightExpression();

			if (complete) {
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AllOrAnyExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AndExpression expression) {

			complete = expression.hasRightExpression();

			if (complete) {
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AvgFunction expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(BetweenExpression expression) {

			complete = expression.hasAnd() && expression.hasUpperBoundExpression();

			if (complete) {
				expression.getUpperBoundExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CaseExpression expression) {
			complete = expression.hasEnd();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CoalesceExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionMemberDeclaration expression) {
			complete = expression.hasIdentificationVariable();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionMemberExpression expression) {

			complete = expression.hasCollectionValuedPathExpression();

			if (complete) {
				expression.getCollectionValuedPathExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionValuedPathExpression expression) {
			complete = !expression.endsWithDot();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ComparisonExpression expression) {

			complete = expression.hasRightExpression();

			if (complete) {
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ConcatExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ConstructorExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CountFunction expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DateTime expression) {
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DivisionExpression expression) {

			complete = expression.hasRightExpression();

			if (complete) {
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(EntryExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ExistsExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FuncExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression) {
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IndexExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(InputParameter expression) {
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(KeyExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(LengthExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(LocateExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(LowerExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MaxFunction expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MinFunction expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ModExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MultiplicationExpression expression) {

			complete = expression.hasRightExpression();

			if (complete) {
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NotExpression expression) {
			complete = expression.hasExpression();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NullIfExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NumericLiteral expression) {
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ObjectExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(OrExpression expression) {

			complete = expression.hasRightExpression();

			if (complete) {
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SizeExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SqrtExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(StateFieldPathExpression expression) {
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(StringLiteral expression) {
			complete = expression.hasCloseQuote();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SubExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SubtractionExpression expression) {

			complete = expression.hasRightExpression();

			if (complete) {
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SubstringExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SumFunction expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(TrimExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(TypeExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(UpperExpression expression) {
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ValueExpression expression) {
			complete = expression.hasRightParenthesis();
		}
	}

	private class WhereClauseCompletenessVisitor extends CompletenessVisitor {

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NullExpression expression) {
			complete = true;
		}
	}

	/**
	 * Example: "WHERE "
	 */
	private class WhereClauseHelper implements ClauseHelper<WhereClause> {

		/**
		 * {@inheritDoc}
		 */
		public void addChoices(WhereClause expression) {
			addIdentificationVariables();
			addAllPossibleFunctions(ConditionalExpressionBNF.ID);
		}

		/**
		 * {@inheritDoc}
		 */
		public Expression getClauseExpression(WhereClause expression) {
			return expression.getConditionalExpression();
		}
	}
}