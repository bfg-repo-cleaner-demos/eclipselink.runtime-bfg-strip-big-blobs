/*******************************************************************************
 * Copyright (c) 1998, 2010 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0
 * which accompanies this distribution.
 * The Eclipse Public License is available athttp://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Oracle
 *
 ******************************************************************************/
package org.eclipse.persistence.utils.jpa.query.parser;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import org.eclipse.persistence.utils.jpa.query.ContentAssistItems;
import org.eclipse.persistence.utils.jpa.query.parser.OrderByItem.Ordering;
import org.eclipse.persistence.utils.jpa.query.spi.IJPAVersion;
import org.eclipse.persistence.utils.jpa.query.spi.IQuery;

import static org.eclipse.persistence.utils.jpa.query.parser.AbstractExpression.*;
import static org.eclipse.persistence.utils.jpa.query.parser.Expression.*;

/**
 * This visitor traverses the JPQL parsed tree and gather the possible choices
 * at a given position.
 * <p>
 * Note: It does not retrieve the possible state fields and collection valued
 * fields because it does not have access to the class metadata.
 *
 * @version 11.2.0
 * @since 11.2.0
 * @author Pascal Filion
 */
@SuppressWarnings({ "nls", "unused" })
public final class ContentAssistVisitor extends AbstractTraverseParentVisitor
{
	/**
	 * This is used to change the position of the cursor in order to add possible
	 * choices
	 */
	private Stack<Integer> corrections;

	/**
	 * The set of possible choices gathered based on the position in the query.
	 */
	private ContentAssistItems items;

	/**
	 * Used to prevent and infinite recursion when one of the visit method is
	 * virtually asking a child expression to be visited.
	 */
	private Expression parentLocked;

	/**
	 * Used to determine if the cursor is an expression contained in a collection,
	 * if not, then this value is set to -1.
	 */
	private int positionInCollection;

	/**
	 * The external representation of the query used to retrieve the possible choices
	 * at a certain position.
	 */
	private IQuery query;

	/**
	 * Contains the position of the cursor within the parsed {@link Expression}.
	 */
	private QueryPosition queryPosition;

	/**
	 * This helper is used to complete the behavior of
	 * {@link #visitSelectStatement(AbstractSelectStatement, ISelectStatementHelper)}
	 * when it's called for {@link SelectStatement}.
	 */
	private SelectStatementHelper selectStatementHelper;

	/**
	 * This helper is used to complete the behavior of
	 * {@link #visitSelectStatement(AbstractSelectStatement, ISelectStatementHelper)}
	 * when it's called for {@link SimpleSelectStatement}.
	 */
	private SimpleSelectStatementHelper simpleSelectStatementHelper;

	/**
	 * A virtual space is used to move the position by an amount of space in
	 * order to find some choices within an expression. This is usually used when
	 * the trailing whitespace is not owned by the child expression but by one of
	 * its parents.
	 */
	private int virtualSpace;

	/**
	 * The current word based on the query and the position of the cursor. The
	 * word is what is on the left side of the cursor.
	 */
	private String word;

	/**
	 * This is used to retrieve words from the actual query.
	 */
	private WordParser wordParser;

	/**
	 * Creates a new <code>ContentAssistVisitor</code>.
	 *
	 * @param query The external representation of the Java Persistence query
	 * @param items The object used to store the possible choices gathered based
	 * on the position in the query
	 * @param queryPosition Contains the position of the cursor within the parsed
	 * {@link Expression}
	 * @param actualQuery The actual query is the text version of the query that
	 * may contain extra whitespace and different formatting than the trim down
	 * version generated by the parsed tree
	 */
	public ContentAssistVisitor(IQuery query,
	                            ContentAssistItems items,
	                            QueryPosition queryPosition)
	{
		super();
		initialize(query, items, queryPosition);
	}

	private void addAbstractSchemaNames()
	{
		for (Iterator<String> iter = query.getProvider().entityNames(); iter.hasNext(); )
		{
			String abstractSchemaName = iter.next();

			if (isValidChoice(abstractSchemaName, word))
			{
				items.addAbstractSchemaName(abstractSchemaName);
			}
		}
	}

	private void addAllPossibleAggregates(JPQLQueryBNF queryBNF)
	{
		for (Iterator<String> iter = identifiers(queryBNF); iter.hasNext(); )
		{
			addPossibleAggregate(iter.next());
		}
	}

	private void addAllPossibleAggregates(String queryBNFId)
	{
		addAllPossibleAggregates(queryBNF(queryBNFId));
	}

	private void addAllPossibleClauses(JPQLQueryBNF queryBNF, int position)
	{
		for (Iterator<String> iter = identifiers(queryBNF); iter.hasNext(); )
		{
			addPossibleClause(iter.next());
		}
	}

	private void addAllPossibleCompoundFunctions(JPQLQueryBNF queryBNF,
	                                             int position)
	{
		for (Iterator<String> iter = identifiers(queryBNF); iter.hasNext(); )
		{
			addPossibleCompoundFunction(iter.next(), position);
		}
	}

	private void addAllPossibleCompoundFunctions(String queryBNFId, int position)
	{
		addAllPossibleCompoundFunctions(queryBNF(queryBNFId), position);
	}

	private void addAllPossibleFunctions(JPQLQueryBNF queryBNF, int position)
	{
		for (Iterator<String> iter = identifiers(queryBNF); iter.hasNext(); )
		{
			addPossibleFunction(iter.next(), position);
		}
	}

	private void addAllPossibleFunctions(String queryBNFId)
	{
		addAllPossibleFunctions(queryBNF(queryBNFId), queryPosition.getPosition());
	}

	private void addAllPossibleFunctions(String queryBNFId, int position)
	{
		addAllPossibleFunctions(queryBNF(queryBNFId), position);
	}

	private void addAllPossibleIdentifiers(AbstractExpression expression)
	{
		int position = position(expression);

		for (Iterator<String> iter = identifiers(expression); iter.hasNext(); )
		{
			addPossibleIdentifier(iter.next(), position);
		}
	}

	private void addAllPossibleIdentifiers(JPQLQueryBNF queryBNF)
	{
		for (Iterator<String> iter = identifiers(queryBNF); iter.hasNext(); )
		{
			addPossibleChoice(iter.next());
		}
	}

	private void addAllPossibleIdentifiers(String queryBNFId)
	{
		addAllPossibleIdentifiers(queryBNF(queryBNFId));
	}

	private void addIdentificationVariables(Expression expression)
	{
		addIdentificationVariables
		(
			expression,
			IdentificationVariableFromDeclarationVisitor.Type.ALL
		);
	}

	private void addIdentificationVariables(Expression expression,
	                                        IdentificationVariableFromDeclarationVisitor.Type type)
	{
		// First retrieve visit the expression and gather the identification variables
		IdentificationVariableFromDeclarationVisitor visitor = new IdentificationVariableFromDeclarationVisitor(type);
		expression.getRoot().accept(visitor);

		for (String identificationVariable : visitor.identificationVariables)
		{
			if (isValidChoice(identificationVariable, word))
			{
				items.addIdentificationVariable(identificationVariable);
			}
		}
	}

	private void addOptionalClausesAfterWhereClause(AbstractSelectStatement expression,
	                                                int position)
	{
		ConditionalExpressionFinder finderVisitor = new ConditionalExpressionFinder();
		expression.getWhereClause().accept(finderVisitor);

		if (finderVisitor.conditionalExpression != null)
		{
			TrailingCompleteness completenessVisitor = new TrailingCompleteness();
			finderVisitor.conditionalExpression.accept(completenessVisitor);

			if (completenessVisitor.complete)
			{
				addPossibleClauses(expression, new GroupByClauseHelper(), position + ((virtualSpace == 1) ? 0 : virtualSpace));
			}
		}
	}

	private void addPossibleAbstractSchemaName(String abstractSchemaName)
	{
		if (isValidChoice(abstractSchemaName, word))
		{
			items.addAbstractSchemaName(abstractSchemaName);
		}
	}

	private void addPossibleAggregate(String choice)
	{
		if (isAggregate(choice))
		{
			addPossibleChoice(choice);
		}
	}

	private void addPossibleChoice(String choice)
	{
		addPossibleChoice(choice, word);
	}

	private void addPossibleChoice(String identifier, String word)
	{
		if (isValidChoice(identifier, word) &&
		    isValidVersion(identifier))
		{
			items.addIdentifier(identifier);
		}
	}

	private void addPossibleClause(String identifier)
	{
		if (isClause(identifier))
		{
			addPossibleChoice(identifier);
		}
	}

	private void addPossibleClauses(AbstractSelectStatement expression,
	                                ClauseHelper helper,
	                                int position)
	{
		addPossibleIdentifier(helper.identifier(), position);

		// The clause isn't defined, then iterate through the other optional
		// clauses, sequentially
		if (!helper.hasClause(expression))
		{
			// Go to the next optional clause
			helper = helper.nextClauseHelper(expression);

			while (helper != null)
			{
				addPossibleIdentifier(helper.identifier(), position);

				// The previous clause isn't present, we can add the clause that
				// follows it as a choice
				if (helper.hasClause(expression))
				{
					break;
				}

				helper = helper.nextClauseHelper(expression);
			}
		}
	}

	private void addPossibleCompoundFunction(String choice, int position)
	{
		if (isCompoundFunction(choice))
		{
			String currentWord = word;
			int endPosition = position - word.length();

			// Check to see if the previous words are "IS", "IS NOT" and "NOT",
			// they are special case since the only allowed identifiers are
			// those starting with them
			if (wordParser.endsWith(endPosition, "IS NOT"))
			{
				currentWord = new StringBuilder("IS NOT ").append(word).toString();
			}
			else if (wordParser.endsWith(endPosition, "IS"))
			{
				currentWord = new StringBuilder("IS ").append(word).toString();
			}
			else if (wordParser.endsWith(endPosition, "NOT"))
			{
				currentWord = new StringBuilder("NOT ").append(word).toString();
			}
			else
			{
				addPossibleChoice(choice);
				currentWord = null;
			}

			if (currentWord != null                &&
			    isValidChoice(choice, currentWord) &&
			    isValidVersion(choice))
			{
				items.addIdentifier(choice);
			}
		}
	}

	private void addPossibleFunction(String choice, int position)
	{
		if (isFunction(choice))
		{
			String currentWord = word;
			int endPosition = position - word.length();

			// Check to see if the previous words are "IS", "IS NOT" and "NOT",
			// they are special case since the only allowed identifiers are
			// those starting with them
			if (wordParser.endsWith(endPosition, "IS NOT"))
			{
				currentWord = new StringBuilder("IS NOT ").append(word).toString();
			}
			else if (wordParser.endsWith(endPosition, "IS"))
			{
				currentWord = new StringBuilder("IS ").append(word).toString();
			}
			else if (wordParser.endsWith(endPosition, "NOT"))
			{
				currentWord = new StringBuilder("NOT ").append(word).toString();
			}
			else
			{
				addPossibleChoice(choice);
				currentWord = null;
			}

			if (currentWord != null                &&
			    isValidChoice(choice, currentWord) &&
			    isValidVersion(choice))
			{
				items.addIdentifier(choice);
			}
		}
	}

	private void addPossibleIdentifier(String identifier, int position)
	{
		String currentWord = word;

		// Check for multiple words identifier
		if (identifier.indexOf(SPACE) > 0)
		{
			String previousWord = wordParser.previousWord(position);

			if (previousWord.length() > 0)
			{
				currentWord = new StringBuilder(previousWord).append(" ").append(word).toString();
			}
		}

		if (isValidChoice(identifier, currentWord) &&
		    isValidVersion(identifier))
		{
			items.addIdentifier(identifier);
		}
		else
		{
			addPossibleChoice(identifier);
		}
	}

	private void addRangeIdentificationVariables(Expression expression)
	{
		addIdentificationVariables
		(
			expression,
			IdentificationVariableFromDeclarationVisitor.Type.RANGE
		);
	}

	private int findExpressionPosition(CollectionExpression expression)
	{
		Expression leafExpression = queryPosition.getExpression();

		if (leafExpression != expression)
		{
			for (int index = 0, count = expression.childrenSize(); index < count; index++)
			{
				Expression child = expression.getChild(index);

				if (child.isAncestor(leafExpression))
				{
					return index;
				}
			}
		}

		int position = position(expression);

		if (position > -1)
		{
			for (int index = 0, count = expression.childrenSize(); index < count; index++)
			{
				Expression child = expression.getChild(index);
				String text = child.toParsedText();

				if (position <= text.length())
				{
					return index;
				}

				position -= text.length();

				if (expression.hasComma(index))
				{
					position--;
				}

				if (expression.hasSpace(index))
				{
					position--;
				}
			}
		}

		if (position == 0 && (expression.endsWithComma() || expression.endsWithSpace()))
		{
			return expression.childrenSize();
		}

		return -1;
	}

	private boolean hasFromClauseDeclaration(AbstractSelectStatement expression)
	{
		FromClauseDeclarationVisitor visitor = new FromClauseDeclarationVisitor();
		expression.getFromClause().accept(visitor);
		return visitor.declarationDeclared;
	}

	private boolean hasGroupByClauseDeclaration(AbstractSelectStatement expression)
	{
		GroupByClauseDeclarationVisitor visitor = new GroupByClauseDeclarationVisitor();
		expression.getGroupByClause().accept(visitor);
		return visitor.declarationDeclared;
	}

	private IdentifierRole identifierRole(String identifier)
	{
		return AbstractExpression.identifierRole(identifier);
	}

	private Iterator<String> identifiers(AbstractExpression expression)
	{
		return identifiers(expression.getQueryBNF());
	}

	private Iterator<String> identifiers(JPQLQueryBNF queryBNF)
	{
		return queryBNF.identifiers();
	}

	private void initialize(IQuery query,
	                        ContentAssistItems items,
	                        QueryPosition queryPosition)
	{
		this.positionInCollection        = -1;
		this.items                       = items;
		this.query                       = query;
		this.queryPosition               = queryPosition;
		this.corrections                 = new Stack<Integer>();
		this.wordParser                  = new WordParser(query.getExpression());
		this.word                        = wordParser.partialWord(queryPosition.getPosition());
		this.selectStatementHelper       = new SelectStatementHelper();
		this.simpleSelectStatementHelper = new SimpleSelectStatementHelper();

		this.corrections.add(0);
	}

	private boolean isAggregate(String choice)
	{
		return identifierRole(choice) == IdentifierRole.AGGREGATE;
	}

	private boolean isClause(String identifier)
	{
		return JPQLExpression.identifierRole(identifier) == IdentifierRole.CLAUSE;
	}

	private boolean isCompoundFunction(String choice)
	{
		return identifierRole(choice) == IdentifierRole.COMPOUND_FUNCTION;
	}

	private boolean isFunction(String choice)
	{
		return identifierRole(choice) == IdentifierRole.FUNCTION;
	}

	private boolean isPositionWithin(int position, String word)
	{
		return position > -1 && position < word.length();
	}

	private boolean isPositionWithin(String text,
	                                 String matchingText,
	                                 int position)
	{
		int index = text.toLowerCase().indexOf(matchingText.toLowerCase());
		return position >= index && position < index + matchingText.length();
	}

	private boolean isValidChoice(String choice, String word)
	{
		// There is no word to match the first letters
		if (word.length() == 0)
		{
			return true;
		}

		// The word is longer than the choice or word is the choice,
		// we don't need to show it
		if (word.length() > choice.length() ||
		    choice.equalsIgnoreCase(word))
		{
			return false;
		}

		// Check to see if the choice starts with the word
		for (int index = 0, length = word.length(); index < length; index++)
		{
			char character1 = choice.charAt(index);
			char character2 = word  .charAt(index);

			// If characters don't match but case may be ignored, try converting
			// both characters to uppercase. If the results match, then the
			// comparison scan should continue
			char upperCase1 = Character.toUpperCase(character1);
			char upperCase2 = Character.toUpperCase(character2);

			if (upperCase1 != upperCase2)
			{
				return false;
			}

			// Unfortunately, conversion to uppercase does not work properly for
			// the Georgian alphabet, which has strange rules about case
			// conversion. So we need to make one last check before exiting
			if (Character.toLowerCase(upperCase1) != Character.toLowerCase(upperCase2))
			{
				return false;
			}
		}

		return true;
	}

	private boolean isValidVersion(String identifier)
	{
		IJPAVersion identifierVersion = JPQLExpression.identifierVersion(identifier);
		return version().isNewerThanOrEqual(identifierVersion);
	}

	private Expression lastLeaf(Expression expression)
	{
		for (Iterator<Expression> iter = expression.children(); iter.hasNext(); )
		{
			Expression child = iter.next();

			if (!iter.hasNext())
			{
				return lastLeaf(child);
			}
		}

		if (((AbstractExpression) expression).isNull())
		{
			expression = expression.getParent();
		}

		return expression;
	}

	private int length(Expression expression)
	{
		return expression.toParsedText().length();
	}

	private int position(Expression expression)
	{
		return queryPosition.getPosition(expression);
	}

	private int position(Expression expression, char character)
	{
		return expression.toParsedText().indexOf(character);
	}

	private JPQLQueryBNF queryBNF(String queryBNFId)
	{
		return AbstractExpression.queryBNF(queryBNFId);
	}

	private IJPAVersion version()
	{
		return query.getProvider().getVersion();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(AbsExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// Within "ABS"
		if (isPositionWithin(position, ABS))
		{
			items.addIdentifier(ABS);
		}
		// After "ABS("
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
			addAllPossibleFunctions(SimpleArithmeticExpressionBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(AbstractSchemaName expression)
	{
		corrections.add(-position(expression));
		super.visit(expression);
		corrections.pop();

		for (Iterator<String> iter = query.getProvider().entityNames(); iter.hasNext(); )
		{
			addPossibleAbstractSchemaName(iter.next());
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(AllOrAnyExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// Within "ALL"
		if (isPositionWithin(position, ALL))
		{
			items.addIdentifier(ALL);
		}
		// Within "SOME"
		if (isPositionWithin(position, SOME))
		{
			items.addIdentifier(SOME);
		}
		// Within "ANY"
		if (isPositionWithin(position, ANY))
		{
			items.addIdentifier(ANY);
		}

		// After "<identifier>("
		if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addAllPossibleFunctions(SubQueryBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(AvgFunction expression)
	{
		super.visit(expression);
		visitFunction(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(BadExpression expression)
	{
		corrections.add(-position(expression));
		super.visit(expression);
		corrections.pop();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(BetweenExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// Within "BETWEEN"
		if (isPositionWithin(position, BETWEEN))
		{
			items.addIdentifier(BETWEEN);
		}
		else
		{
			// At the end of the expression, AND is the only viable choices
			String parsedText = expression.toParsedText();

			if (position + corrections.peek() == parsedText.length() + virtualSpace)
			{
				// Only add AND if it's not present and the upper bound expression
				// is not declared
				if (!expression.hasAnd() &&
				    !expression.hasUpperBoundExpression())
				{
					addPossibleChoice(AND);
				}
			}

			// Check to see if the position is within the AND identifier
			if (expression.hasAnd() &&
			    isPositionWithin(parsedText, AND, position))
			{
				addPossibleChoice(AND);
			}

			if (!expression.hasAnd() &&
			    !expression.hasUpperBoundExpression() &&
			     positionInCollection > -1)
			{
				addPossibleChoice(AND);
			}

			StringBuilder sb = new StringBuilder();
			sb.append(expression.getExpression().toParsedText());

			if (expression.hasExpression())
			{
				sb.append(SPACE);
			}

			// 'NOT'
			if (expression.hasNot())
			{
				sb.append(NOT);
				sb.append(SPACE);
			}

			// 'BETWEEN'
			sb.append(BETWEEN);

			if (expression.hasSpaceAfterBetween())
			{
				sb.append(SPACE);
			}

			// Lower bound expression
			sb.append(expression.getLowerBoundExpression().toParsedText());

			if (expression.hasSpaceAfterLowerBound())
			{
				sb.append(SPACE);
			}

			if (!expression.hasAnd() && position + corrections.peek() == sb.length())
			{
				addPossibleChoice(AND);
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CaseExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// Within "CASE"
		if (isPositionWithin(position, CASE))
		{
			if (isValidVersion(CASE))
			{
				items.addIdentifier(CASE);
			}
		}
		// After "CASE "
		else if (position + corrections.peek() == CASE.length() + 1)
		{
			addPossibleChoice(WHEN);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CoalesceExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// Within "COALESCE"
		if (isPositionWithin(position, COALESCE))
		{
			if (isValidVersion(COALESCE))
			{
				items.addIdentifier(COALESCE);
			}
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addAllPossibleFunctions(ScalarExpressionBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CollectionExpression expression)
	{
		positionInCollection = findExpressionPosition(expression);

		if (positionInCollection > -1)
		{
			corrections.add(-position(expression));
		}

		super.visit(expression);

		if (positionInCollection > -1)
		{
			corrections.pop();
		}

		positionInCollection = -1;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CollectionMemberDeclaration expression)
	{
		int position = position(expression);

		// IN
		if (isPositionWithin(position, IN))
		{
			items.addIdentifier(IN);
		}
		// After '(' or space
		else if (position + corrections.peek() == IN.length() + 1)
		{
			if (corrections.peek() == 0)
			{
				addRangeIdentificationVariables(expression);
			}

			addAllPossibleIdentifiers(CollectionValuedPathExpressionBNF.ID);
		}
		// After ')'
		else if (position + corrections.peek() == expression.toParsedTextUntilAs().length())
		{
			addPossibleChoice(AS);
		}
		else
		{
			super.visit(expression);

			// At the end of the expression, AS and identification variable are the
			// only viable choices
			String parsedText = expression.toParsedText();

			if (position + corrections.peek() == parsedText.length() + virtualSpace)
			{
				// Only add AS if it's not present and before the position
				if (!expression.hasAs())
				{
					addPossibleChoice(AS);
				}
			}

			// Check to see if the position is within the AS identifier
			if (expression.hasAs() &&
			    isPositionWithin(parsedText, AS, position))
			{
				addPossibleChoice(AS);
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CollectionMemberExpression expression)
	{
		super.visit(expression);

		int position = position(expression);
		int memberLength = expression.getIdentifier().toString().length();
		int entryExpressionLength = length(expression.getEntityExpression()) + 1;

		// Within "MEMBER"
		if (isPositionWithin(position - entryExpressionLength, MEMBER))
		{
			items.addIdentifier(MEMBER);
		}
		// After "MEMBER" or "NOT MEMBER", check to add "OF"
		else if (!expression.hasOf() && position + corrections.peek() == entryExpressionLength + memberLength)
		{
			if (expression.hasNot())
			{
				items.addIdentifier(NOT_MEMBER_OF);
			}
			else
			{
				items.addIdentifier(MEMBER_OF);
			}
		}
		// After the identifier and space
		else if (position + corrections.peek() == entryExpressionLength + memberLength + 1)
		{
			if (!expression.hasOf())
			{
				addPossibleChoice(OF);
			}

			addRangeIdentificationVariables(expression);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CollectionValuedPathExpression expression)
	{
		int position = position(expression);

		if (!expression.hasIdentificationVariable())
		{
			corrections.add(-position(expression));
			super.visit(expression);
			corrections.pop();
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ComparisonExpression expression)
	{
		super.visit(expression);

		String comparisonOperator = expression.getComparisonOperator();
		int position              = position(expression);
		int leftExpressionLength  = length(expression.getLeftExpression());
		int comparisonLength      = comparisonOperator.length();
		int spaceAfterComparison  = expression.hasSpaceAfterIdentifier() ? 1 : 0;

		// After the left expression, possible choices are the comparison identifiers
		if (position + corrections.peek() == leftExpressionLength + 1)
		{
			addPossibleChoice(DIFFERENT);
		}

		// After the first character of the comparison symbol
		if (position + corrections.peek() == leftExpressionLength + 2 &&
		    comparisonLength == 1)
		{
			addPossibleChoice(DIFFERENT,             comparisonOperator);
			addPossibleChoice(GREATER_THAN_OR_EQUAL, comparisonOperator);
			addPossibleChoice(LOWER_THAN_OR_EQUAL,   comparisonOperator);
		}

		// After the comparison identifier
		if (position + corrections.peek() == leftExpressionLength + comparisonLength + spaceAfterComparison + 1)
		{
			JPQLQueryBNF queryBNF = expression.rightExpressionBNF();
			position = queryPosition.getPosition();

			addAllPossibleFunctions(queryBNF, position);
			addAllPossibleClauses  (queryBNF, position);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ConcatExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// CONTACT
		if (isPositionWithin(position, CONCAT))
		{
			items.addIdentifier(CONCAT);
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addAllPossibleFunctions(StringPrimaryBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ConstructorExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// NEW
		if (isPositionWithin(position, NEW))
		{
			items.addIdentifier(NEW);
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
			addAllPossibleFunctions(ConstructorItemBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(CountFunction expression)
	{
		super.visit(expression);
		visitFunction(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(DateTime expression)
	{
		super.visit(expression);
		int position = position(expression);

		// Within the identifier
		if (isPositionWithin(position, CURRENT_DATE) ||
		    isPositionWithin(position, CURRENT_TIME) ||
		    isPositionWithin(position, CURRENT_TIMESTAMP))
		{
			addPossibleChoice(CURRENT_DATE);
			addPossibleChoice(CURRENT_TIME);
			addPossibleChoice(CURRENT_TIMESTAMP);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(DeleteClause expression)
	{
		super.visit(expression);
		int position = position(expression);

		// Within "DELETE"
		if (isPositionWithin(position, DELETE))
		{
			if (expression.hasFrom())
			{
				items.addIdentifier(DELETE);
			}
			else
			{
				items.addIdentifier(DELETE_FROM);
			}
		}
		// After "DELETE"
		else if (position + corrections.peek() == DELETE.length())
		{
			items.addIdentifier(DELETE_FROM);
		}
		// After "DELETE "
		else if (position + corrections.peek() == DELETE.length() + 1)
		{
			items.addIdentifier(FROM);
		}
		// Within "FROM"
		else if (isPositionWithin(position - DELETE.length() - 1, FROM))
		{
			items.addIdentifier(FROM);
		}
		// After "DELETE FROM "
		else if (position + corrections.peek() == DELETE_FROM.length() + 1)
		{
			addAbstractSchemaNames();
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(DeleteStatement expression)
	{
		super.visit(expression);

		int position            = position(expression);
		int deleteClauseLength  = length(expression.getDeleteClause());

		// The cursor is right after "DELETE FROM ... "
		if (position + corrections.peek() == deleteClauseLength + 1)
		{
			addPossibleChoice(WHERE);
		}
		// The position is after the DeleteStatement, which means it's in the
		// JPQLExpression's unknown statement
		else if (virtualSpace != 0 && position == deleteClauseLength + 1)
		{
			addPossibleChoice(WHERE);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(EntryExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// ENTRY
		if (isPositionWithin(position, ENTRY))
		{
			if (isValidVersion(ENTRY))
			{
				items.addIdentifier(ENTRY);
			}
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ExistsExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// EXISTS
		if (isPositionWithin(position, EXISTS))
		{
			items.addIdentifier(EXISTS);
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addAllPossibleFunctions(SubQueryBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(FromClause expression)
	{
		super.visit(expression);
		int position = position(expression);

		// Within "FROM"
		if (isPositionWithin(position, FROM))
		{
			items.addIdentifier(FROM);
		}
		// After "FROM "
		else if (position + corrections.peek() == FROM.length() + 1)
		{
			// With the correction, check to see if the possible identifiers (IN)
			// can be added and only if it's not the first item in the list
			if (positionInCollection > -1)
			{
				FromDeclarationCompleteness completenessVisitor = new FromDeclarationCompleteness();
				expression.getDeclaration().accept(completenessVisitor);

				if (completenessVisitor.complete)
				{
					if (position == length(expression) && completenessVisitor.canAddAbstractSchemaName)
					{
						addAbstractSchemaNames();
					}

					if (positionInCollection > 0)
					{
						addAllPossibleIdentifiers(InternalFromClauseBNF.ID);
					}
				}
			}
			else
			{
				addAbstractSchemaNames();
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(FuncExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// Within "FUNC"
		if (isPositionWithin(position, FUNC))
		{
			if (isValidVersion(FUNC))
			{
				items.addIdentifier(FUNC);
			}
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addAllPossibleFunctions(InternalFuncExpressionBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(IdentificationVariable expression)
	{
		corrections.add(-position(expression));
		super.visit(expression);
		corrections.pop();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(IdentificationVariableDeclaration expression)
	{
		super.visit(expression);

		if (expression.hasSpace())
		{
			StringBuilder sb = new StringBuilder();
			sb.append(expression.getRangeVariableDeclaration().toParsedText());
			sb.append(SPACE);

			int position = position(expression);

			if (position == sb.length())
			{
				// TODO: Update ExpressionFactory to support composite identifiers
				addPossibleChoice(INNER_JOIN);
				addPossibleChoice(INNER_JOIN_FETCH);
				addPossibleChoice(JOIN);
				addPossibleChoice(JOIN_FETCH);
				addPossibleChoice(LEFT_JOIN);
				addPossibleChoice(LEFT_JOIN_FETCH);
				addPossibleChoice(LEFT_OUTER_JOIN);
				addPossibleChoice(LEFT_OUTER_JOIN_FETCH);
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(IndexExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// VALUE
		if (isPositionWithin(position, INDEX))
		{
			if (isValidVersion(INDEX))
			{
				items.addIdentifier(INDEX);
			}
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(Join expression)
	{
		super.visit(expression);

		int position = position(expression);
		Join.Type join = expression.getIdentifier();

		// Within "LEFT JOIN"
		if ((join == Join.Type.LEFT_JOIN) && isPositionWithin(position, LEFT_JOIN))
		{
			items.addIdentifier(LEFT_JOIN);

			// Within "LEFT" or after "LEFT "
			if (isPositionWithin(position, LEFT)               ||
			    position + corrections.peek() == LEFT.length() ||
			    position + corrections.peek() == LEFT.length() + 1)
			{
				items.addIdentifier(LEFT_OUTER_JOIN);
			}
		}
		// Within "JOIN"
		else if ((join == Join.Type.JOIN) && isPositionWithin(position, JOIN))
		{
			items.addIdentifier(Join.JOIN);
		}
		// Within "LEFT OUTER JOIN"
		else if ((join == Join.Type.LEFT_OUTER_JOIN) && isPositionWithin(position, LEFT_OUTER_JOIN))
		{
			items.addIdentifier(LEFT_OUTER_JOIN);

			// Within "LEFT"
			if (isPositionWithin(position, LEFT)               ||
			    position + corrections.peek() == LEFT.length() ||
			    position + corrections.peek() == LEFT.length() + 1)
			{
				items.addIdentifier(LEFT_JOIN);
			}
		}
		// After "<join_spec> join_association_path "
		else if (position > -1 &&
		         expression.hasJoinAssociationPath() &&
		         expression.hasSpaceAfterJoinAssociation())
		{
			StringBuilder sb = new StringBuilder();
			sb.append(join.toString());
			sb.append(SPACE);
			sb.append(expression.getJoinAssociationPath().toParsedText());
			sb.append(SPACE);

			if (position + corrections.peek() == sb.length() ||
			    position + corrections.peek() == sb.length() + 1)
			{
				addPossibleChoice(AS);
			}
		}
		else if (position == -1)
		{
			// TODO: Update ExpressionFactory to support composite identifiers
			addPossibleChoice(INNER_JOIN);
			addPossibleChoice(INNER_JOIN_FETCH);
			addPossibleChoice(JOIN);
			addPossibleChoice(JOIN_FETCH);
			addPossibleChoice(LEFT_JOIN);
			addPossibleChoice(LEFT_JOIN_FETCH);
			addPossibleChoice(LEFT_OUTER_JOIN);
			addPossibleChoice(LEFT_OUTER_JOIN_FETCH);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(JoinFetch expression)
	{
		super.visit(expression);

		int position = position(expression);
		JoinFetch.Type join = expression.getIdentifier();

		// Within "LEFT JOIN FETCH"
		if ((join == JoinFetch.Type.LEFT_JOIN_FETCH) && isPositionWithin(position, LEFT_JOIN_FETCH))
		{
			items.addIdentifier(LEFT_JOIN_FETCH);

			// Within "LEFT" or after "LEFT "
			if (isPositionWithin(position, LEFT)               ||
			    position + corrections.peek() == LEFT.length() ||
			    position + corrections.peek() == LEFT.length() + 1)
			{
				items.addIdentifier(LEFT_OUTER_JOIN_FETCH);
			}
		}
		// Within "JOIN"
		else if ((join == JoinFetch.Type.JOIN_FETCH) && isPositionWithin(position, JOIN_FETCH))
		{
			items.addIdentifier(Join.JOIN_FETCH);
		}
		// Within "LEFT OUTER JOIN FETCH"
		else if ((join == JoinFetch.Type.LEFT_OUTER_JOIN_FETCH) && isPositionWithin(position, LEFT_OUTER_JOIN_FETCH))
		{
			items.addIdentifier(LEFT_OUTER_JOIN_FETCH);

			// Within "LEFT"
			if (isPositionWithin(position, LEFT)               ||
			    position + corrections.peek() == LEFT.length() ||
			    position + corrections.peek() == LEFT.length() + 1)
			{
				items.addIdentifier(LEFT_JOIN_FETCH);
			}
		}
		// After "<join_spec> join_association_path "
		else if (position > -1 &&
		         expression.hasJoinAssociationPath())
		{
			StringBuilder sb = new StringBuilder();
			sb.append(join.toString());
			sb.append(SPACE);
			sb.append(expression.getJoinAssociationPath().toParsedText());
			sb.append(SPACE);

			if (position + corrections.peek() == sb.length() ||
			    position + corrections.peek() == sb.length() + 1)
			{
				addPossibleChoice(AS);
			}
		}
		else if (position == -1)
		{
			// TODO: Update ExpressionFactory to support composite identifiers
			addPossibleChoice(INNER_JOIN);
			addPossibleChoice(INNER_JOIN_FETCH);
			addPossibleChoice(JOIN);
			addPossibleChoice(JOIN_FETCH);
			addPossibleChoice(LEFT_JOIN);
			addPossibleChoice(LEFT_JOIN_FETCH);
			addPossibleChoice(LEFT_OUTER_JOIN);
			addPossibleChoice(LEFT_OUTER_JOIN_FETCH);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(JPQLExpression expression)
	{
		// Prevent infinite recursion
		if (parentLocked == expression)
		{
			return;
		}

		int position = position(expression);
		Expression queryStatement = expression.getQueryStatement();
		Expression unknownStatement = expression.getUnknownEndingStatement();

		// At the beginning of the expression
		if (position + corrections.peek() == 0)
		{
			if (corrections.peek() == 0)
			{
				addPossibleChoice(Expression.SELECT);
				addPossibleChoice(Expression.UPDATE);
				addPossibleChoice(Expression.DELETE_FROM);
			}
			// The query is not valid, it does not even have the beginning of a
			// valid query, so we use the entire text to check what is valid
			else
			{
				String text = expression.toParsedText();
				String word = text.substring(0, position);

				addPossibleChoice(Expression.SELECT,      word);
				addPossibleChoice(Expression.UPDATE,      word);
				addPossibleChoice(Expression.DELETE_FROM, word);
			}
		}
		else if (queryPosition.getExpression() == unknownStatement &&
		         position > length(queryStatement))
		{
			virtualSpace = position(unknownStatement);
			parentLocked = expression;
			corrections.add(0);
			String oldWord = word;

			if (word.length() == 0)
			{
				word = unknownStatement.toParsedText().substring(0, virtualSpace);
			}

			Expression childExpression = lastLeaf(queryStatement);
			queryPosition.addPosition(childExpression, length(childExpression));
			childExpression.accept(this);

			word = oldWord;
			virtualSpace = 0;
			parentLocked = null;
			corrections.pop();
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(KeyExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// KEY
		if (isPositionWithin(position, KEY))
		{
			if (isValidVersion(KEY))
			{
				items.addIdentifier(KEY);
			}
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			visitEncapsulatedIdentificationVariable(expression);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(KeywordExpression expression)
	{
		corrections.add(-position(expression));
		super.visit(expression);
		corrections.pop();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(LengthExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// LENGTH
		if (isPositionWithin(position, LENGTH))
		{
			items.addIdentifier(LENGTH);
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
			addAllPossibleFunctions(StringPrimaryBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(LikeExpression expression)
	{
		super.visit(expression);

		int position               = position(expression);
		int stringExpressionLength = length(expression.getStringExpression());

		// Before "LIKE" or "NOT LIKE"
		if (position + corrections.peek() == stringExpressionLength + 1)
		{
			items.addIdentifier(LIKE);
			items.addIdentifier(NOT_LIKE);
		}
		// Within "LIKE"
		else if (!expression.hasNot() && isPositionWithin(position - stringExpressionLength - 1, LIKE))
		{
			items.addIdentifier(LIKE);
		}
		// Within "NOT LIKE"
		else if (expression.hasNot() && isPositionWithin(position - stringExpressionLength - 1, NOT_LIKE))
		{
			items.addIdentifier(NOT_LIKE);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(LocateExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// LOCATE
		if (isPositionWithin(position, LOCATE))
		{
			items.addIdentifier(LOCATE);
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
			addAllPossibleFunctions(StringPrimaryBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(LowerExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// LOWER
		if (isPositionWithin(position, LOWER))
		{
			items.addIdentifier(LOWER);
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
			addAllPossibleFunctions(StringPrimaryBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(MaxFunction expression)
	{
		super.visit(expression);
		visitFunction(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(MinFunction expression)
	{
		super.visit(expression);
		visitFunction(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ModExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// MOD
		if (isPositionWithin(position, MOD))
		{
			items.addIdentifier(MOD);
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
			addAllPossibleFunctions(SimpleArithmeticExpressionBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(NullIfExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// NULLIF
		if (isPositionWithin(position, NULLIF))
		{
			if (isValidVersion(NULLIF))
			{
				items.addIdentifier(NULLIF);
			}
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
			addAllPossibleFunctions(ScalarExpressionBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ObjectExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// NEW
		if (isPositionWithin(position, OBJECT))
		{
			items.addIdentifier(OBJECT);
		}
		// After '('
		else if (position == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(OrderByItem expression)
	{
		super.visit(expression);

		int position = position(expression);
		int length   = length(expression);

		if ((position + corrections.peek() == length) && (expression.getOrdering() == Ordering.DEFAULT) ||
		    virtualSpace > 0 && -corrections.peek() + 1 == length)
		{
			addPossibleChoice(ASC);
			addPossibleChoice(DESC);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(RangeVariableDeclaration expression)
	{
		super.visit(expression);

		int position = position(expression);
		String schemaName = expression.getAbstractSchemaName().toParsedText();

		// After "<schema name>"
		if (position > -1 && position + corrections.peek() <= schemaName.length())
		{
			addAbstractSchemaNames();
		}
		// After "<schema name> " or within "AS"
		else if (position + corrections.peek() == schemaName.length() + 1 ||
		         position + corrections.peek() == schemaName.length() + 2)
		{
			addPossibleChoice(AS);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SelectClause expression)
	{
		super.visit(expression);
		visitSelectClause(expression, SelectItemBNF.ID);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SelectStatement expression)
	{
		// Prevent infinite recursion
		if (parentLocked != expression)
		{
			super.visit(expression);
			visitSelectStatement(expression, selectStatementHelper);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SimpleSelectClause expression)
	{
		super.visit(expression);
		visitSelectClause(expression, SimpleSelectExpressionBNF.ID);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SimpleSelectStatement expression)
	{
		// Prevent infinite recursion
		if (parentLocked != expression)
		{
			// Don't continue traversing the parent hierarchy because a subquery
			// will handle all the possible choices
			visitSelectStatement(expression, simpleSelectStatementHelper);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SqrtExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// SQRT
		if (isPositionWithin(position, SQRT))
		{
			items.addIdentifier(SQRT);
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
			addAllPossibleFunctions(SimpleArithmeticExpressionBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(StateFieldPathExpression expression)
	{
		int position = position(expression);

		if (!expression.hasIdentificationVariable())
		{
			corrections.add(-position(expression));
			super.visit(expression);
			corrections.pop();
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SubExpression expression)
	{
		corrections.add(-position(expression));
		super.visit(expression);
		corrections.pop();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SubstringExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// SUBSTRING
		if (isPositionWithin(position, SUBSTRING))
		{
			items.addIdentifier(SUBSTRING);
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
			addAllPossibleFunctions(StringPrimaryBNF.ID);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(SumFunction expression)
	{
		super.visit(expression);
		visitFunction(expression);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(TrimExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// TRIM
		if (isPositionWithin(position, TRIM))
		{
			items.addIdentifier(TRIM);
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addPossibleChoice(BOTH);
			addPossibleChoice(LEADING);
			addPossibleChoice(TRAILING);
			addIdentificationVariables(expression);
			addAllPossibleFunctions(StringPrimaryBNF.ID);
		}
		else
		{
			StringBuilder writer = new StringBuilder();

			// 'TRIM'
			writer.append(TRIM);

			// '('
			if (expression.hasLeftParenthesis())
			{
				writer.append(LEFT_PARENTHESIS);
			}

			// Trim specification
			if (expression.hasSpecification())
			{
				writer.append(expression.getSpecification().name());
			}

			if (expression.hasSpaceAfterSpecification())
			{
				writer.append(SPACE);
			}

			// Trim character
			if (expression.hasTrimCharacter())
			{
				writer.append(expression.getTrimCharacter());
			}

			if (expression.hasSpaceAfterTrimCharacter())
			{
				writer.append(SPACE);
			}

			// After the character
			if (position + corrections.peek() == writer.length())
			{
				addPossibleChoice(FROM);

				if (!expression.hasFrom())
				{
					addIdentificationVariables(expression);
					addAllPossibleFunctions(StringPrimaryBNF.ID);
				}
			}

			if (expression.hasFrom())
			{
				writer.append(FROM);
			}

			if (expression.hasSpaceAfterFrom())
			{
				writer.append(SPACE);
			}

			// After the FROM
			if (position + corrections.peek() == writer.length())
			{
				addIdentificationVariables(expression);
				addAllPossibleFunctions(StringPrimaryBNF.ID);
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(TypeExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// TYPE
		if (isPositionWithin(position, TYPE))
		{
			if (isValidVersion(TYPE))
			{
				items.addIdentifier(TYPE);
			}
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(UnknownExpression expression)
	{
		corrections.add(-position(expression));
		super.visit(expression);
		corrections.pop();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(UpdateClause expression)
	{
		super.visit(expression);
		int position = position(expression);

		// Within "UPDATE"
		if (isPositionWithin(position, UPDATE))
		{
			items.addIdentifier(UPDATE);
		}
		// After "UPDATE "
		else if (position + corrections.peek() == UPDATE.length() + 1)
		{
			addAbstractSchemaNames();
		}
		else
		{
			// Rebuild the query so we know how to match the cursor within
			// the UPDATE clause
			StringBuilder sb = new StringBuilder();
			sb.append(UPDATE);

			if (expression.hasSpaceAfterUpdate())
			{
				sb.append(SPACE);
			}

			sb.append(expression.getRangeVariableDeclaration().toParsedText());

			if (expression.hasSpaceAfterRangeVariableDeclaration())
			{
				sb.append(SPACE);

				if (position + corrections.peek() == sb.length())
				{
					addPossibleChoice(SET);
				}
			}

			if (expression.hasSet())
			{
				sb.append(SET);
			}

			// Within "SET"
			if (position + corrections.peek() == sb.length())
			{
				// Before we add SET, we need to make sure the range variable
				// declaration is complete, if for instance it does not have the
				// identification variable, then SET should be a valid choice
				RangeVariableDeclarationCompleteness completeness = new RangeVariableDeclarationCompleteness();
				expression.getRangeVariableDeclaration().accept(completeness);

				if (completeness.complete)
				{
					addPossibleChoice(SET);
				}
			}
			else
			{
				if (expression.hasSpaceAfterSet())
				{
					sb.append(SPACE);
				}

				// After "SET "
				if (position + corrections.peek() == sb.length())
				{
					addIdentificationVariables(expression);
				}
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(UpdateItem expression)
	{
		super.visit(expression);
		int position = position(expression);

		if (position + corrections.peek() == 0)
		{
			addIdentificationVariables(expression);
		}
		else
		{
			StringBuilder sb = new StringBuilder();
			sb.append(expression.getStateFieldPathExpression().toParsedText());

			if ((position == sb.length()) && !expression.hasSpaceAfterStateFieldPathExpression())
			{
				items.addIdentifier(EQUAL);
			}
			else if (expression.hasSpaceAfterStateFieldPathExpression())
			{
				sb.append(SPACE);

				if (position == sb.length())
				{
					items.addIdentifier(EQUAL);
				}
			}

			if (expression.hasEqualSign())
			{
				sb.append(EQUAL);

				if (position == sb.length())
				{
					addAllPossibleIdentifiers(NewValueBNF.ID);
				}
			}

			if (expression.hasSpaceAfterEqualSign())
			{
				sb.append(SPACE);
			}

			if (position + corrections.peek() == sb.length())
			{
				addAllPossibleIdentifiers(NewValueBNF.ID);
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(UpdateStatement expression)
	{
		// Prevent infinite recursion
		if (parentLocked == expression)
		{
			return;
		}

		super.visit(expression);

		int position           = position(expression);
		int updateClauseLength = length(expression.getUpdateClause());
		int whereClauseLength  = length(expression.getWhereClause());

		int updateClauseSpace  = expression.hasSpaceAfterUpdateClause() ? 1 : 0;

		//
		// UPDATE
		//
		int length = updateClauseLength + updateClauseSpace;

		// The cursor is right after "UPDATE "
		if (position == UPDATE.length() + 1)
		{
			addAbstractSchemaNames();
		}

		// The cursor is after the UPDATE clause
		if ((position == length) && (expression.getUpdateClause().toParsedText().endsWith(" ") || updateClauseSpace > 0))
		{
			TrailingCompleteness visitor = new TrailingCompleteness();
			expression.getUpdateClause().accept(visitor);

			if (visitor.complete)
			{
				addPossibleChoice(WhereClause.WHERE);
			}

			parentLocked = expression;

			if (virtualSpace == 0)
			{
				virtualSpace = 1;
			}

			// First, dig into the leaf expression
			Expression childExpression = lastLeaf(expression.getUpdateClause());
			Integer oldPosition = queryPosition.getPosition(childExpression);
			int oldPositionInCollection = positionInCollection;
			queryPosition.addPosition(childExpression, childExpression.toParsedText().length());
			childExpression.accept(this);

			if (oldPosition != null)
			{
				queryPosition.addPosition(childExpression, oldPosition);
			}
			else
			{
				queryPosition.removePosition(childExpression);
			}

			positionInCollection = oldPositionInCollection;
			virtualSpace = 0;
			parentLocked = null;
		}

		//
		// WHERE
		//
		length += whereClauseLength;

		// The cursor is after the WHERE clause
		if (position == length)
		{
			parentLocked = expression;

			if (virtualSpace == 0)
			{
				virtualSpace = 1;
			}

			// First, dig into the leaf expression
			Expression childExpression = expression.getWhereClause();
			int previousPosition = position(childExpression);
			queryPosition.addPosition(childExpression, whereClauseLength + 1);
			childExpression.accept(this);
			queryPosition.addPosition(childExpression, previousPosition);

			virtualSpace = 0;
			parentLocked = expression;
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(ValueExpression expression)
	{
		super.visit(expression);
		int position = position(expression);

		// VALUE
		if (isPositionWithin(position, VALUE))
		{
			if (isValidVersion(VALUE))
			{
				items.addIdentifier(VALUE);
			}
		}
		// After '('
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addIdentificationVariables(expression);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void visit(WhereClause expression)
	{
		super.visit(expression);

		int position          = position(expression);
		int whereClauseLength = length(expression);

		// Within "WHERE"
		if (isPositionWithin(position, WHERE))
		{
			items.addIdentifier(WHERE);
		}
		// After "WHERE "
		else if (position + corrections.peek() == WHERE.length() + 1)
		{
			addIdentificationVariables(expression);
			addAllPossibleFunctions(ConditionalExpressionBNF.ID, queryPosition.getPosition());

			if (positionInCollection > -1)
			{
				addAllPossibleCompoundFunctions(ConditionalExpressionBNF.ID, queryPosition.getPosition());
			}
		}
		else if (virtualSpace != 0 && position >= whereClauseLength + 1)
		{
			int globalPosition = position(expression.getRoot());

			// If there is already a conditional expression, check to see if
			// it can be wrapped to become a compound expression, example:
			// "AVG(e.age) " could become "AVG(e.age) BETWEEN 21 AND 64", which
			// means BETWEEN can be a possible choice
			if (expression.hasConditionalExpression())
			{
				CompoundableVisitor compoundableVisitor = new CompoundableVisitor();
				expression.getConditionalExpression().accept(compoundableVisitor);

				if (compoundableVisitor.compoundable)
				{
					addAllPossibleCompoundFunctions(ConditionalExpressionBNF.ID, globalPosition);
				}

				// Now check for aggregate functions
				TrailingCompleteness completenessVisitor = new TrailingCompleteness();
				expression.getConditionalExpression().accept(completenessVisitor);

				if (completenessVisitor.complete)
				{
					addAllPossibleAggregates(ConditionalExpressionBNF.ID);
				}
			}
			else
			{
				addAllPossibleFunctions(ConditionalExpressionBNF.ID);
			}
		}
	}

	private void visitEncapsulatedIdentificationVariable(EncapsulatedIdentificationVariableExpression expression)
	{
		// Find the FROM clause
		FromClauseFinder fromClauseFinder = new FromClauseFinder();
		expression.accept(fromClauseFinder);

		// Collect the identification variables used to identify collection-valued
		// members from the FROM clause
		IdentificationVariablesFromCollectionDeclarationVisitor visitor =
			new IdentificationVariablesFromCollectionDeclarationVisitor(expression);

		if (fromClauseFinder.fromClause != null)
		{
			fromClauseFinder.fromClause.accept(visitor);
		}

		for (String item : visitor.items)
		{
			addPossibleChoice(item);
		}
	}

	private void visitFunction(AggregateFunction expression)
	{
		int position = position(expression);
		String identifier = expression.getText();

		// Within "<identifier>"
		if (isPositionWithin(position, identifier))
		{
			items.addIdentifier(identifier);
		}
		// After "<identifier>("
		else if (position + corrections.peek() == position(expression, LEFT_PARENTHESIS) + 1)
		{
			addPossibleChoice(DISTINCT);

			if (!expression.hasDistinct())
			{
				addIdentificationVariables(expression);
			}
		}
		else if (expression.hasDistinct() && expression.hasLeftParenthesis())
		{
			// Within "DISTINCT", +1 for (
			if (isPositionWithin(position - identifier.length() + 1, DISTINCT))
			{
				addPossibleChoice(DISTINCT);
			}
			else
			{
				// +2 is for ( and the space after DISTINCT
				int identificationVariablePosition = identifier.length() + 2 + DISTINCT.length();

				// After "<identifier>(DISTINCT "
				if (position + corrections.peek() == identificationVariablePosition)
				{
					addIdentificationVariables(expression);
				}
			}
		}
	}

	private void visitSelectClause(AbstractSelectClause expression,
	                               String selectExpressionBNFId)
	{
		int position = position(expression);

		// SELECT
		if (isPositionWithin(position, SELECT))
		{
			items.addIdentifier(SELECT);
		}
		// Space
		else if (position + corrections.peek() == SELECT.length() + 1)
		{
			if (corrections.peek() == 0)
			{
				addPossibleChoice(DISTINCT);
			}

			addIdentificationVariables(expression);

			// Make sure the possible function can be added
			SelectExpressionCompleteness completenessVisitor = new SelectExpressionCompleteness(positionInCollection);
			expression.getSelectExpression().accept(completenessVisitor);

			if (completenessVisitor.complete)
			{
				addAllPossibleFunctions(SelectItemBNF.ID);
			}
		}
	}

	private <T extends AbstractSelectStatement> void visitSelectStatement(T expression,
	                                                                      ISelectStatementHelper<T> helper)
	{
		int position            = position(expression);
		int selectClauseLength  = length(expression.getSelectClause());
		int fromClauseLength    = length(expression.getFromClause());
		int whereClauseLength   = length(expression.getWhereClause());
		int groupByClauseLength = length(expression.getGroupByClause());
		int havingClauseLength  = length(expression.getHavingClause());

		int selectClauseSpace   = expression.hasSpaceAfterSelect()  ? 1 : 0;
		int fromClauseSpace     = expression.hasSpaceAfterFrom()    ? 1 : 0;
		int whereClauseSpace    = expression.hasSpaceAfterWhere()   ? 1 : 0;
		int groupByClauseSpace  = expression.hasSpaceAfterGroupBy() ? 1 : 0;
		int havingClauseSpace   = helper.hasSpaceAfterHavingClause(expression) ? 1 : 0;

		//
		// SELECT
		//
		int length = selectClauseLength + selectClauseSpace;

		// The cursor is right after "SELECT "
		if (position == SELECT.length() + 1)
		{
			addPossibleChoice(DISTINCT);
			addIdentificationVariables(expression);
			addAllPossibleFunctions(SelectItemBNF.ID);
		}

		// The cursor is after the SELECT clause
		if (position == length)
		{
			// Check if the select items are complete, if they are
			// then FROM can be a choice
			SelectClauseCompleteness completeness = new SelectClauseCompleteness();
			expression.getSelectClause().accept(completeness);

			if (completeness.complete)
			{
				addPossibleChoice(FROM);

				// The cursor is after a select item and a whitespace,
				// which means the select item can be identified by a
				// result variable, show the AS identifier
				if (selectClauseSpace == 1)
				{
					addPossibleChoice(AS);
				}
			}
		}

		//
		// FROM
		//
		length += fromClauseLength + fromClauseSpace;

		// The cursor is after the FROM clause
		if (position == length)
		{
			parentLocked = expression;

			if (virtualSpace == 0)
			{
				virtualSpace = 1;
			}

			// First, dig into the leaf expression
			Expression childExpression = lastLeaf(expression.getFromClause());
			Integer oldPosition = queryPosition.getPosition(childExpression);
			int oldPositionInCollection = positionInCollection;
			queryPosition.addPosition(childExpression, length(childExpression) + 1);
			childExpression.accept(this);

			if (oldPosition != null)
			{
				queryPosition.addPosition(childExpression, oldPosition);
			}
			else
			{
				queryPosition.removePosition(childExpression);
			}

			positionInCollection = oldPositionInCollection;

			// Now loop to check if we can add the identifiers of clauses
			if (hasFromClauseDeclaration(expression))
			{
				FromClauseCompleteness completeness = new FromClauseCompleteness();
				expression.getFromClause().accept(completeness);

				if (completeness.complete && (fromClauseSpace == 1 || expression.getFromClause().toParsedText().endsWith(" ")))
				{
					addPossibleClauses(expression, new WhereClauseHelper(), position + ((virtualSpace == 1) ? 0 : virtualSpace));
				}
			}

			virtualSpace = 0;
			parentLocked = null;
		}

		//
		// WHERE
		//
		length += whereClauseLength + whereClauseSpace;

		// The cursor is after the WHERE clause
		if (position == length)
		{
			parentLocked = expression;

			if (virtualSpace == 0)
			{
				virtualSpace = 1;
			}

			// First, dig into the leaf expression
			Expression childExpression = expression.getWhereClause();
			Integer oldPosition = position(childExpression);
			int oldPositionInCollection = positionInCollection;
			queryPosition.addPosition(childExpression, whereClauseLength + whereClauseSpace);
			childExpression.accept(this);

			if (oldPosition != null)
			{
				queryPosition.addPosition(childExpression, oldPosition);
			}
			else
			{
				queryPosition.removePosition(childExpression);
			}

			positionInCollection = oldPositionInCollection;

			virtualSpace = 0;
			parentLocked = null;

			// Now check if we can add the optional clauses following the WHERE clause
			NextClauseInsertable insertableVisitor = new NextClauseInsertable();
			expression.getWhereClause().accept(insertableVisitor);

			if (whereClauseSpace > 0 || insertableVisitor.insertable)
			{
				addOptionalClausesAfterWhereClause(expression, position);
			}
		}

		//
		// GROUP BY
		//
		length += groupByClauseLength + groupByClauseSpace;

		// The cursor is after the GROUP BY clause
		if (position == length)
		{
			parentLocked = expression;

			if (virtualSpace == 0)
			{
				virtualSpace = 1;
			}

			// First, dig into the leaf expression
			Expression childExpression = expression.getGroupByClause();
			Integer oldPosition = position(childExpression);
			int oldPositionInCollection = positionInCollection;
			queryPosition.addPosition(childExpression, childExpression.toParsedText().length() + 1);
			childExpression.accept(this);

			if (oldPosition != null)
			{
				queryPosition.addPosition(childExpression, oldPosition);
			}
			else
			{
				queryPosition.removePosition(childExpression);
			}

			positionInCollection = oldPositionInCollection;

			// Now loop to check if we can add the identifiers of clauses that
			// follow the GROUP BY clause
			if (hasGroupByClauseDeclaration(expression))
			{
				addPossibleClauses(expression, new HavingClauseHelper(), position + ((virtualSpace == 1) ? 0 : virtualSpace));
			}

			virtualSpace = 0;
			parentLocked = null;
		}

		//
		// HAVING
		//
		length += havingClauseLength + havingClauseSpace;

		// The cursor is after the HAVING clause
		if (position == length)
		{
			parentLocked = expression;

			if (virtualSpace == 0)
			{
				virtualSpace = 1;
			}

			// First, dig into the leaf expression
			Expression childExpression = expression.getHavingClause();
			Integer oldPosition = position(childExpression);
			int oldPositionInCollection = positionInCollection;
			queryPosition.addPosition(childExpression, childExpression.toParsedText().length() + 1);
			childExpression.accept(this);

			if (oldPosition != null)
			{
				queryPosition.addPosition(childExpression, oldPosition);
			}
			else
			{
				queryPosition.removePosition(childExpression);
			}

			virtualSpace = 0;
			parentLocked = null;
			positionInCollection = oldPositionInCollection;

			// Now check to add the next clause
			NextClauseInsertable insertableVisitor = new NextClauseInsertable();
			expression.getHavingClause().accept(insertableVisitor);

			if (havingClauseSpace > 0 || insertableVisitor.insertable)
			{
				helper.addClauseAfterHavingClause();
			}
		}
	}

	/**
	 * A <code>ClauseHelper</code> manages the existence of a clause within the
	 * select statement (top-level or in a sub-query) and also determine what is
	 * the valid successor clause.
	 */
	private interface ClauseHelper
	{
		/**
		 * Determines whether the given select statement has the clause managed by
		 * this helper.
		 *
		 * @param statement The select statement to query for the existence of the
		 * clause
		 * @return <code>true</code> if the clause is defined for the given select
		 * statement; <code>false</code> otherwise
		 */
		boolean hasClause(AbstractSelectStatement statement);

		/**
		 * Returns the JPQL identifier of the clause managed by this helper.
		 *
		 * @return The clause identifier
		 */
		String identifier();

		/**
		 * Creates the <code>ClauseHelper</code> of the clause that follows the
		 * one managed by this helper.
		 *
		 * @param statement The select statement for which the helper of the next
		 * clause is requested
		 * @return The <code>ClauseHelper</code> of the next clause or <code>null</code>
		 * if there is no clause that can follow the one managed by this helper
		 */
		ClauseHelper nextClauseHelper(AbstractSelectStatement statement);
	}

	private static class CompoundableVisitor extends AbstractExpressionVisitor
	{
		/**
		 * Determines if the {@link Expression} can be compounded, which means if
		 * it can be the left part of a compound expression.
		 */
		private boolean compoundable;

		private void checkCompleteness(Expression expression)
		{
			TrailingCompleteness visitor = new TrailingCompleteness();
			expression.accept(visitor);

			compoundable = visitor.complete;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AbsExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AdditionExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AndExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AvgFunction expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(BetweenExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression)
		{
			// A CollectionExpression here could mean the query is incomplete but
			// it could become compoundable
			int lastIndex = expression.childrenSize() - 1;
			expression.getChild(lastIndex).accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionMemberExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CountFunction expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DivisionExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression)
		{
			compoundable = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(LengthExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MaxFunction expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MinFunction expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ModExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MultiplicationExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NotExpression expression)
		{
			compoundable = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SizeExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SqrtExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(StateFieldPathExpression expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SumFunction expression)
		{
			checkCompleteness(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(UnknownExpression expression)
		{
			// The unknown expression has "IS", which can be part
			// of a compound expression
			String text = expression.toParsedText();
			compoundable = NullComparisonExpression.IS.equalsIgnoreCase(text);
		}
	}

	private static class ConditionalExpressionFinder extends AbstractExpressionVisitor
	{
		/**
		 *
		 */
		private Expression conditionalExpression;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(WhereClause expression)
		{
			conditionalExpression = expression.getConditionalExpression();
		}
	}

	private static class FromClauseCompleteness extends AbstractExpressionVisitor
	{
		/**
		 * Determines whether an {@link Expression} that was visited was complete
		 * or if there some parts are missing.
		 */
		protected boolean complete;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression)
		{
			if (expression.endsWithComma() ||
			    expression.endsWithSpace())
			{
				complete = false;
			}
			else
			{
				int lastIndex = expression.childrenSize() - 1;
				AbstractExpression child = (AbstractExpression) expression.getChild(lastIndex);

				if (child.isNull())
				{
					complete = false;
				}
				else
				{
					expression.getChild(lastIndex).accept(this);
				}
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FromClause expression)
		{
			expression.getDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariableDeclaration expression)
		{
			expression.getRangeVariableDeclaration().accept(this);

			if (complete)
			{
				expression.getJoins().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(Join expression)
		{
			complete = expression.hasIdentificationVariable();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(JoinFetch expression)
		{
			complete = expression.hasJoinAssociationPath();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(RangeVariableDeclaration expression)
		{
			complete = expression.hasIdentificationVariable();
		}
	}

	private static class FromClauseDeclarationVisitor extends AbstractExpressionVisitor
	{
		/**
		 *
		 */
		private boolean declarationDeclared;

		/**
		 * Creates a new <code>FromClauseDeclarationVisitor</code>.
		 */
		FromClauseDeclarationVisitor()
		{
			super();
			this.declarationDeclared = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(BadExpression expression)
		{
			declarationDeclared = false;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FromClause expression)
		{
			expression.getDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NullExpression expression)
		{
			declarationDeclared = false;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleFromClause expression)
		{
			expression.getDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(UnknownExpression expression)
		{
			declarationDeclared = false;
		}
	}

	private static class FromClauseFinder extends AbstractTraverseParentVisitor
	{
		/**
		 *
		 */
		private AbstractFromClause fromClause;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FromClause expression)
		{
			fromClause = expression;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(JPQLExpression expression)
		{
			expression.getQueryStatement().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SelectStatement expression)
		{
			expression.getFromClause().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleFromClause expression)
		{
			fromClause = expression;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleSelectStatement expression)
		{
			expression.getFromClause().accept(this);
		}
	}

	private static class FromDeclarationCompleteness extends TrailingCompleteness
	{
		private boolean canAddAbstractSchemaName;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression)
		{
			// If the last item is null, then the declaration of the FROM clause
			// is complete, which means more choices can be used
			if (expression.endsWithComma() ||
			    expression.endsWithSpace())
			{
				complete = true;
				canAddAbstractSchemaName = true;
			}
			else
			{
				int lastIndex = expression.childrenSize() - 1;
				AbstractExpression child = (AbstractExpression) expression.getChild(lastIndex);

				if (child.isNull())
				{
					complete = true;
					canAddAbstractSchemaName = true;
				}
				else
				{
					child.accept(this);
				}
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionMemberDeclaration expression)
		{
			super.visit(expression);
			canAddAbstractSchemaName = false;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression)
		{
			super.visit(expression);
			canAddAbstractSchemaName = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariableDeclaration expression)
		{
			if (!expression.hasJoins())
			{
				expression.getRangeVariableDeclaration().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(RangeVariableDeclaration expression)
		{
			// Special case where only the abstract schema name is specified
			complete = !expression.hasAs() &&
			           !expression.hasSpaceAfterAbstractSchemaName() &&
			           !expression.hasIdentificationVariable();
		}
	}

	private static class GroupByClauseDeclarationVisitor extends AbstractExpressionVisitor
	{
		private boolean declarationDeclared;

		GroupByClauseDeclarationVisitor()
		{
			super();
			this.declarationDeclared = true;
		}

		@Override
		public void visit(BadExpression expression)
		{
			declarationDeclared = false;
		}

		@Override
		public void visit(GroupByClause expression)
		{
			expression.getGroupByItems().accept(this);
		}

		@Override
		public void visit(NullExpression expression)
		{
			declarationDeclared = false;
		}

		@Override
		public void visit(UnknownExpression expression)
		{
			declarationDeclared = false;
		}
	}

	/**
	 * This {@link ClauseHelper} manages the <b>GROUP BY</b> clause and what's
	 * coming after.
	 */
	private static class GroupByClauseHelper implements ClauseHelper
	{
		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean hasClause(AbstractSelectStatement statement)
		{
			return statement.hasGroupByClause();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String identifier()
		{
			return GROUP_BY;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public ClauseHelper nextClauseHelper(AbstractSelectStatement statement)
		{
			return new HavingClauseHelper();
		}
	}

	/**
	 * This {@link ClauseHelper} manages the <b>HAVING</b> clause and what's
	 * coming after.
	 */
	private static class HavingClauseHelper implements ClauseHelper
	{
		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean hasClause(AbstractSelectStatement statement)
		{
			return statement.hasHavingClause();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String identifier()
		{
			return HAVING;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public ClauseHelper nextClauseHelper(AbstractSelectStatement statement)
		{
			OrderByClauseHelperBuilder builder = new OrderByClauseHelperBuilder();
			statement.accept(builder);
			return builder.helper;
		}
	}

	private static class IdentificationVariableFromDeclarationVisitor extends AbstractExpressionVisitor
	{
		/**
		 * The identification variable names mapped to their abstract schema names
		 * or collection-valued path expressions.
		 */
		private Set<String> identificationVariables;

		/**
		 * The type of identification variables to retrieve, which helps to filter
		 * out those from a different declaration.
		 */
		private Type type;

		/**
		 * Creates a new <code>IdentificationVariableFromDeclarationVisitor</code>.
		 *
		 * @param parent The parent of this resolver, which is never
		 * <code>null</code>
		 * @param type The type of identification variables to retrieve, which
		 * helps to filter out those from a different declaration
		 */
		IdentificationVariableFromDeclarationVisitor(Type type)
		{
			super();

			this.type = type;
			this.identificationVariables = new HashSet<String>();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression)
		{
			for (Iterator<Expression> children = expression.children(); children.hasNext(); )
			{
				children.next().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionMemberDeclaration expression)
		{
			if (type == Type.COLLECTION || type == Type.ALL)
			{
				IdentificationVariableVisitor visitor = new IdentificationVariableVisitor();
				expression.getIdentificationVariable().accept(visitor);
				String variableName = visitor.identificationVariableName();

				if (ExpressionTools.stringIsNotEmpty(variableName))
				{
					identificationVariables.add(variableName);
				}
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DeleteClause expression)
		{
			expression.getRangeVariableDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DeleteStatement expression)
		{
			expression.getDeleteClause().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FromClause expression)
		{
			expression.getDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariableDeclaration expression)
		{
			expression.getRangeVariableDeclaration().accept(this);
			expression.getJoins().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(Join expression)
		{
			if (type == Type.JOIN || type == Type.ALL)
			{
				IdentificationVariableVisitor visitor = new IdentificationVariableVisitor();
				expression.getIdentificationVariable().accept(visitor);
				String variableName = visitor.identificationVariableName();

				if (ExpressionTools.stringIsNotEmpty(variableName))
				{
					identificationVariables.add(variableName);
				}
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(JPQLExpression expression)
		{
			expression.getQueryStatement().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(RangeVariableDeclaration expression)
		{
			if (type == Type.RANGE || type == Type.ALL)
			{
				IdentificationVariableVisitor visitor = new IdentificationVariableVisitor();
				expression.getIdentificationVariable().accept(visitor);
				String variableName = visitor.identificationVariableName();

				if (ExpressionTools.stringIsNotEmpty(variableName))
				{
					identificationVariables.add(variableName);
				}
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SelectStatement expression)
		{
			expression.getFromClause().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleFromClause expression)
		{
			expression.getDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleSelectStatement expression)
		{
			expression.getFromClause().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(UpdateClause expression)
		{
			expression.getRangeVariableDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(UpdateStatement expression)
		{
			expression.getUpdateClause().accept(this);
		}

		enum Type
		{
			ALL,
			COLLECTION,
			JOIN,
			RANGE
		}
	}

	private static class IdentificationVariablesFromCollectionDeclarationVisitor extends AbstractExpressionVisitor
	{
		private boolean completed;
		private Expression expression;
		private List<String> items;

		IdentificationVariablesFromCollectionDeclarationVisitor(Expression expression)
		{
			super();

			this.expression = expression;
			this.items      = new ArrayList<String>();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression)
		{
			for (Iterator<Expression> children = expression.children(); children.hasNext(); )
			{
				children.next().accept(this);

				if (completed)
				{
					break;
				}
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionMemberDeclaration expression)
		{
			if (expression.isAncestor(this.expression))
			{
				completed = true;
			}

			if (!completed)
			{
				expression.getIdentificationVariable().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FromClause expression)
		{
			expression.getDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression)
		{
			String variableName = expression.toParsedText();

			if (ExpressionTools.stringIsNotEmpty(variableName))
			{
				items.add(variableName);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariableDeclaration expression)
		{
			expression.getJoins().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(Join expression)
		{
			if (expression.isAncestor(this.expression))
			{
				completed = true;
			}

			if (!completed)
			{
				expression.getIdentificationVariable().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(KeyExpression expression)
		{
			if (expression.isAncestor(this.expression))
			{
				completed = true;
			}

			if (!completed)
			{
				expression.getExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleFromClause expression)
		{
			expression.getDeclaration().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ValueExpression expression)
		{
			if (expression.isAncestor(this.expression))
			{
				completed = true;
			}

			if (!completed)
			{
				expression.getExpression().accept(this);
			}
		}
	}

	/**
	 * This visitor retrieves the identification variable name.
	 */
	private static class IdentificationVariableVisitor extends AbstractExpressionVisitor
	{
		/**
		 * The identification variable name that is retrieved from
		 * {@link IdentificationVariable} if it was visited.
		 */
		private String identificationVariableName;

		/**
		 * Returns the identification variable name if {@link IdentificationVariable}
		 * was visited.
		 *
		 * @return Either the variable name or <code>null</code> if it was not
		 * visited
		 */
		String identificationVariableName()
		{
			return identificationVariableName;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression)
		{
			identificationVariableName = expression.toParsedText();
		}
	}

	private interface ISelectStatementHelper<T extends AbstractSelectStatement>
	{
		void addClauseAfterHavingClause();

		boolean hasSpaceAfterHavingClause(T expression);
	}

	private class NextClauseInsertable extends AbstractExpressionVisitor
	{
		private boolean insertable;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression)
		{
			insertable = !expression.endsWithComma();

			if (insertable)
			{
				int lastIndex = expression.childrenSize() - 1;
				expression.getChild(lastIndex).accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ComparisonExpression expression)
		{
			expression.getRightExpression().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(GroupByClause expression)
		{
			expression.getGroupByItems().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(HavingClause expression)
		{
			expression.getConditionalExpression().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression)
		{
			insertable = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(WhereClause expression)
		{
			expression.getConditionalExpression().accept(this);
		}
	}

	/**
	 * This {@link ClauseHelper} manages the <b>ORDER BY</b> clause and what's
	 * coming after, and in this case, no more clauses are allowed.
	 */
	private static class OrderByClauseHelper implements ClauseHelper
	{
		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean hasClause(AbstractSelectStatement statement)
		{
			SelectStatement selectStatement = (SelectStatement) statement;
			return selectStatement.hasOrderByClause();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String identifier()
		{
			return ORDER_BY;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public ClauseHelper nextClauseHelper(AbstractSelectStatement statement)
		{
			return null;
		}
	}

	/**
	 * This visitor creates {@link OrderByClauseHelper} if the {@link AbstractSelectStatement}
	 * is {@link SelectStatement} and not {@link SimpleSelectStatement}.
	 */
	private static class OrderByClauseHelperBuilder extends AbstractExpressionVisitor
	{
		/**
		 * The {@link OrderByClauseHelper} is only created if the {@link AbstractSelectStatement}
		 * is {@link SelectStatement} and not {@link SimpleSelectStatement}.
		 */
		private OrderByClauseHelper helper;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SelectStatement expression)
		{
			helper = new OrderByClauseHelper();
		}
	}

	private static class RangeVariableDeclarationCompleteness extends AbstractExpressionVisitor
	{
		/**
		 * Determines whether an {@link Expression} that was visited was complete
		 * or if there some parts are missing.
		 */
		protected boolean complete;

		/**
		 * The count determine how if the range variable declaration is complete.
		 * To be complete, the count has to be 2.
		 */
		private int count;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AbstractSchemaName expression)
		{
			count++;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression)
		{
			count++;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(RangeVariableDeclaration expression)
		{
			expression.getAbstractSchemaName().accept(this);
			expression.getIdentificationVariable().accept(this);

			// If the abstract schema name and identification variable are defined
			// then the count is 2, which means the range variable declaration is
			// complete. If it wasn't, then the visit would have gone in any other
			// expression and the count woudn't have increased to 2
			complete = (count == 2);
		}
	}

	/**
	 * This visitor checks the integrity of the select items.
	 * <p>
	 * The possible JPQL identifiers allowed in a SELECT expression as of JPA 2.0
	 * are:
	 * <ul>
	 * <li> *, /, +, -
	 * <li> ABS
	 * <li> AVG
	 * <li> CASE
	 * <li> COALESCE
	 * <li> CONCAT
	 * <li> COUNT
	 * <li> CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, SQL date
	 * <li> ENTRY
	 * <li> FUNC
	 * <li> KEY
	 * <li> INDEX
	 * <li> LENGTH
	 * <li> LOCATE
	 * <li> LOWER
	 * <li> MAX
	 * <li> MIN
	 * <li> MOD
	 * <li> NEW
	 * <li> NULL
	 * <li> NULLIF
	 * <li> OBJECT
	 * <li> SIZE
	 * <li> SQRT
	 * <li> SUBSTRING
	 * <li> SUM
	 * <li> TRIM
	 * <li> TRUE, FALSE
	 * <li> TYPE
	 * <li> UPPER
	 * <li> VALUE
	 * </ul>
	 */
	private static class SelectClauseCompleteness extends AbstractExpressionVisitor
	{
		/**
		 * Determines whether an {@link Expression} that was visited is complete
		 * or if some part is missing.
		 */
		protected boolean complete;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AbsExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AdditionExpression expression)
		{
			visitArithmeticExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AvgFunction expression)
		{
			visitAggregateFunction(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CaseExpression expression)
		{
			complete = expression.hasEnd();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CoalesceExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression)
		{
			int lastIndex = expression.childrenSize() - 1;
			AbstractExpression child = (AbstractExpression) expression.getChild(lastIndex);

			// The collection ends with an empty element, that's not complete
			if (child.isNull())
			{
				complete = false;
			}
			// If the last item is not separated by a comma with the previous item,
			// then validte the expression
			else if (!expression.hasComma(lastIndex - 1))
			{
				expression.getChild(lastIndex).accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ConcatExpression expression)
		{
			visitAbstractDoubleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ConstructorExpression expression)
		{
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CountFunction expression)
		{
			visitAggregateFunction(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DateTime expression)
		{
			// Always complete if CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP
			// or if the JDBC escape syntax ends with '}'
			complete = expression.isJDBCDate() ? expression.toParsedText().endsWith("}") : true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DivisionExpression expression)
		{
			visitArithmeticExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(EntryExpression expression)
		{
			visitEncapsulatedIdentificationVariableExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(FuncExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression)
		{
			// Always complete
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IndexExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(KeyExpression expression)
		{
			visitEncapsulatedIdentificationVariableExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(KeywordExpression expression)
		{
			// Always complete
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(LengthExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(LocateExpression expression)
		{
			visitAbstractTripleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(LowerExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MaxFunction expression)
		{
			visitAggregateFunction(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MinFunction expression)
		{
			visitAggregateFunction(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ModExpression expression)
		{
			visitAbstractDoubleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MultiplicationExpression expression)
		{
			visitArithmeticExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NullIfExpression expression)
		{
			visitAbstractDoubleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ObjectExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ResultVariable expression)
		{
			complete = expression.hasResultVariable();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SelectClause expression)
		{
			expression.getSelectExpression().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SimpleSelectClause expression)
		{
			expression.getSelectExpression().accept(this);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SizeExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SqrtExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(StateFieldPathExpression expression)
		{
			// Always complete, even if it ends with a dot
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SubstractionExpression expression)
		{
			visitArithmeticExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SubstringExpression expression)
		{
			visitAbstractTripleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SumFunction expression)
		{
			visitAggregateFunction(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(TrimExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(TypeExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(UpperExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ValueExpression expression)
		{
			visitEncapsulatedIdentificationVariableExpression(expression);
		}

		private void visitAbstractDoubleEncapsulatedExpression(AbstractDoubleEncapsulatedExpression expression)
		{
			visitAbstractEncapsulatedExpression(expression);
		}

		private void visitAbstractEncapsulatedExpression(AbstractEncapsulatedExpression expression)
		{
			// If ')' is present, then anything can be added after
			complete = expression.hasRightParenthesis();
		}

		private void visitAbstractSingleEncapsulatedExpression(AbstractSingleEncapsulatedExpression expression)
		{
			visitAbstractEncapsulatedExpression(expression);
		}

		private void visitAbstractTripleEncapsulatedExpression(AbstractTripleEncapsulatedExpression expression)
		{
			visitAbstractEncapsulatedExpression(expression);
		}

		private void visitAggregateFunction(AggregateFunction expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}

		private void visitArithmeticExpression(ArithmeticExpression expression)
		{
			expression.getRightExpression().accept(this);
		}

		private void visitEncapsulatedIdentificationVariableExpression(EncapsulatedIdentificationVariableExpression expression)
		{
			visitAbstractSingleEncapsulatedExpression(expression);
		}
	}

	private static class SelectExpressionCompleteness extends SelectClauseCompleteness
	{
		private final int positionInCollection;

		SelectExpressionCompleteness(int positionInCollection)
		{
			super();
			this.positionInCollection = positionInCollection - 1;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression)
		{
			AbstractExpression child = (AbstractExpression) expression.getChild(positionInCollection);

			// The collection ends with an empty element, that's not complete
			if (child.isNull())
			{
				complete = true;
			}
			// If the last item is not separated by a comma with the previous item,
			// then the expression
			else if (expression.hasComma(positionInCollection))
			{
				expression.getChild(positionInCollection).accept(this);
			}
		}
	}

	private class SelectStatementHelper implements ISelectStatementHelper<SelectStatement>
	{
		/**
		 * {@inheritDoc}
		 */
		@Override
		public void addClauseAfterHavingClause()
		{
			addPossibleChoice(ORDER_BY);
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean hasSpaceAfterHavingClause(SelectStatement expression)
		{
			return expression.hasSpaceBeforeGroupBy();
		}
	}

	private class SimpleSelectStatementHelper implements ISelectStatementHelper<SimpleSelectStatement>
	{
		/**
		 * {@inheritDoc}
		 */
		@Override
		public void addClauseAfterHavingClause()
		{
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean hasSpaceAfterHavingClause(SimpleSelectStatement expression)
		{
			return false;
		}
	}

	private static class TrailingCompleteness extends AbstractExpressionVisitor
	{
		/**
		 * Determines whether an {@link Expression} that was visited was complete
		 * or if there some parts are missing.
		 */
		protected boolean complete;

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AbsExpression expression)
		{
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AdditionExpression expression)
		{
			complete = expression.hasRightExpression();

			if (complete)
			{
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AndExpression expression)
		{
			complete = expression.hasRightExpression();

			if (complete)
			{
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(AvgFunction expression)
		{
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(BetweenExpression expression)
		{
			complete = expression.hasAnd() && expression.hasUpperBoundExpression();

			if (complete)
			{
				expression.getUpperBoundExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionExpression expression)
		{
			int lastIndex = expression.childrenSize() - 1;
			AbstractExpression child = (AbstractExpression) expression.getChild(lastIndex);

			if (child.isNull())
			{
				complete = false;
			}
			else
			{
				child.accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionMemberDeclaration expression)
		{
			complete = expression.hasIdentificationVariable();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CollectionMemberExpression expression)
		{
			complete = expression.hasCollectionValuedPathExpression();

			if (complete)
			{
				expression.getCollectionValuedPathExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(ComparisonExpression expression)
		{
			complete = expression.hasRightExpression();

			if (complete)
			{
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(CountFunction expression)
		{
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(DivisionExpression expression)
		{
			complete = expression.hasRightExpression();

			if (complete)
			{
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(IdentificationVariable expression)
		{
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MaxFunction expression)
		{
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MinFunction expression)
		{
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(MultiplicationExpression expression)
		{
			complete = expression.hasRightExpression();

			if (complete)
			{
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NotExpression expression)
		{
			complete = expression.hasExpression();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(NullExpression expression)
		{
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(OrExpression expression)
		{
			complete = expression.hasRightExpression();

			if (complete)
			{
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(StateFieldPathExpression expression)
		{
			complete = true;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SubExpression expression)
		{
			complete = expression.hasRightParenthesis();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SubstractionExpression expression)
		{
			complete = expression.hasRightExpression();

			if (complete)
			{
				expression.getRightExpression().accept(this);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void visit(SumFunction expression)
		{
			complete = expression.hasRightParenthesis();
		}
	}

	/**
	 * This {@link ClauseHelper} manages the <b>WHERE</b> clause and what's
	 * coming after.
	 */
	private static class WhereClauseHelper implements ClauseHelper
	{
		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean hasClause(AbstractSelectStatement statement)
		{
			return statement.hasWhereClause();
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String identifier()
		{
			return WHERE;
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public ClauseHelper nextClauseHelper(AbstractSelectStatement statement)
		{
			return new GroupByClauseHelper();
		}
	}
}